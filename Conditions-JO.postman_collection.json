{
	"info": {
		"_postman_id": "f947ff95-0eeb-432e-a165-e10bb17d0cf8",
		"name": "Conditions",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "36724395"
	},
	"item": [
		{
			"name": "Fetch Entity Conditions",
			"item": [
				{
					"name": "Fetch Entity Conditions - new creditor entity",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"let conditionResult = responseJSON.conditions;\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Result is an empty conditions array\", function () {\r",
									"    pm.expect(responseJSON.conditions).to.be.an( \"array\" ).that.is.empty;\r",
									"});\r",
									"\r",
									"const targetEntityId = pm.globals.get(\"cdtrNttyId\") + pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
									"const graphPostRequest = utils.getConditionsFromDBPostRequest('entities', targetEntityId);\r",
									"console.log(graphPostRequest);\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    let graphConditionList = utils.getConditionsFromGraph(graphConditionResult);\r",
									"\r",
									"    pm.test(`No conditions for entity [${targetEntityId}] exists in the database`, function () {\r",
									"        pm.expect(graphConditionList.length).to.eql(0);\r",
									"    });\r",
									"\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Obliterate the current contents of the pacs008 global variable\r",
									"pm.globals.set(\"pacs008\", undefined);\r",
									"pm.globals.set(\"dbtrNttyId\", undefined);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAcctId\", undefined);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAgt\", undefined);\r",
									"pm.globals.set(\"cdtrNttyId\", undefined);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAcctId\", undefined);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAgt\", undefined);\r",
									"\r",
									"// Set up the transaction (in memory and in the databases)\r",
									"utils.createNewTransactionSetInMemory();\r",
									"\r",
									"// Retrieve the created pacs.008 message\r",
									"const submittedPacs008Message = JSON.parse(pm.globals.get(\"pacs008\"));\r",
									"\r",
									"// Create identifier variables from the pacs.008 message\r",
									"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
									"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
									"\r",
									"// Load deconstructued identifier variables into global variables\r",
									"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"\r",
									"pm.globals.set(\"syncCache\", \"no\");"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/entity?id={{cdtrNttyId}}&schmenm={{cdtrNttyIdSchmeNm}}&synccache={{syncCache}}",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"admin",
								"event-flow-control",
								"entity"
							],
							"query": [
								{
									"key": "id",
									"value": "{{cdtrNttyId}}"
								},
								{
									"key": "schmenm",
									"value": "{{cdtrNttyIdSchmeNm}}"
								},
								{
									"key": "synccache",
									"value": "{{syncCache}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Create New Entity Condition - Unknown debtor entity",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"let conditionResult = responseJSON.result.conditions;\r",
									"let conditionEntity = responseJSON.result.ntty;\r",
									"let requestMessage = responseJSON.message;\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
									"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
									"let targetEntityId = nttyId + nttyIdSchme;\r",
									"\r",
									"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
									"targetRequestMessage = \"New condition was saved successfully.\"\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Result message matches target result message\", function () {\r",
									"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
									"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
									"    pm.expect(conditionResult.length).to.be.eql(1);\r",
									"});\r",
									"\r",
									"let firstElement = conditionResult[0];\r",
									"\r",
									"pm.test(\"Result condition has a non-empty condId\", function () {\r",
									"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
									"});\r",
									"\r",
									"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must have been defaulted\r",
									"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
									"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
									"    });\r",
									"}\r",
									"\r",
									"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must not have been defaulted\r",
									"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
									"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
									"    });\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
									"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
									"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
									"\r",
									"if (targetConditionResult.prsptv === \"both\") {\r",
									"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"};\r",
									"\r",
									"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
									"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
									"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
									"    });\r",
									"\r",
									"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
									"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"});\r",
									"\r",
									"const graphPostRequest = utils.getConditionsFromDBPostRequest('entities', targetEntityId);\r",
									"console.log(graphPostRequest);\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    let graphConditionList = utils.getConditionsFromGraph(graphConditionResult);\r",
									"\r",
									"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
									"        pm.expect(graphConditionList.length).to.eql(1);\r",
									"    });\r",
									"\r",
									"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
									"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
									"            pm.expect(graphConditionResult.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
									"    });\r",
									"\r",
									"    let edgeList = utils.getConditionPerspectivesFromGraph(graphConditionResult, graphConditionResult.v[0]._key);\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
									"    });\r",
									"\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Obliterate the current contents of the global variables\r",
									"pm.globals.set(\"pacs008\", undefined);\r",
									"pm.globals.set(\"dbtrNttyId\", undefined);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAcctId\", undefined);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAgt\", undefined);\r",
									"pm.globals.set(\"cdtrNttyId\", undefined);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAcctId\", undefined);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAgt\", undefined);\r",
									"\r",
									"// Set up the transaction (in memory only - nothing will exist in the DB yet)\r",
									"utils.createNewTransactionSetInMemory();\r",
									"\r",
									"// Retrieve the created pacs.008 message\r",
									"const submittedPacs008Message = JSON.parse(pm.globals.get(\"pacs008\"));\r",
									"\r",
									"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
									"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
									"\r",
									"// Load deconstructued identifier variables into global variables\r",
									"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"\r",
									"// Set up the condition\r",
									"\r",
									"messageBody = utils.getCreateEntityConditionBody(\r",
									"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
									"    /* Condition Type */ null,          // null defaults 'non-overridable-block'\r",
									"    /* Perspetive */ null,              // null defaults 'both'\r",
									"    /* Inception Date */ null,          // null defaults now()\r",
									"    /* Expiration Date */ null,         // null defaults now() + 24 hours\r",
									"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
									"    /* Entity */ dbtrNttyId,            // null defaults new unknown entity\r",
									"    /* Force Create */ false,           // null defaults true\r",
									"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
									");\r",
									"\r",
									"// Set up body variables\r",
									"pm.globals.set('messageBody', messageBody);\r",
									"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{messageBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"{{path-entity-condition}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create New Entity Condition Manually - Unknown debtor entity",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"let conditionResult = responseJSON.result.conditions;\r",
									"let conditionEntity = responseJSON.result.ntty;\r",
									"let requestMessage = responseJSON.message;\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
									"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
									"let targetEntityId = nttyId + nttyIdSchme;\r",
									"\r",
									"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
									"targetRequestMessage = \"New condition was saved successfully.\"\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Result message matches target result message\", function () {\r",
									"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
									"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
									"    pm.expect(conditionResult.length).to.be.eql(1);\r",
									"});\r",
									"\r",
									"let firstElement = conditionResult[0];\r",
									"\r",
									"pm.test(\"Result condition has a non-empty condId\", function () {\r",
									"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
									"});\r",
									"\r",
									"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must have been defaulted\r",
									"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
									"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
									"    });\r",
									"}\r",
									"\r",
									"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must not have been defaulted\r",
									"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
									"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
									"    });\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
									"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
									"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
									"\r",
									"if (targetConditionResult.prsptv === \"both\") {\r",
									"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"};\r",
									"\r",
									"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
									"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
									"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
									"    });\r",
									"\r",
									"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
									"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"});\r",
									"\r",
									"const graphPostRequest = utils.getConditionsFromDBPostRequest('entities', targetEntityId);\r",
									"console.log(graphPostRequest);\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    let graphConditionList = utils.getConditionsFromGraph(graphConditionResult);\r",
									"\r",
									"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
									"        pm.expect(graphConditionList.length).to.eql(1);\r",
									"    });\r",
									"\r",
									"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
									"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
									"            pm.expect(graphConditionResult.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
									"    });\r",
									"\r",
									"    let edgeList = utils.getConditionPerspectivesFromGraph(graphConditionResult, graphConditionResult.v[0]._key);\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
									"    });\r",
									"\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Obliterate the current contents of the global variables\r",
									"pm.globals.set(\"pacs008\", undefined);\r",
									"pm.globals.set(\"dbtrNttyId\", undefined);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAcctId\", undefined);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAgt\", undefined);\r",
									"pm.globals.set(\"cdtrNttyId\", undefined);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAcctId\", undefined);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAgt\", undefined);\r",
									"\r",
									"// Set up the transaction (in memory only - nothing will exist in the DB yet)\r",
									"utils.createNewTransactionSetInMemory();\r",
									"\r",
									"// Retrieve the created pacs.008 message\r",
									"const submittedPacs008Message = JSON.parse(pm.globals.get(\"pacs008\"));\r",
									"\r",
									"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
									"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
									"\r",
									"// Load deconstructued identifier variables into global variables\r",
									"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"\r",
									"// Set up the condition\r",
									"\r",
									"messageBody = {\r",
									"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
									"  \"condTp\":\"non-overridable-block\",\r",
									"  \"prsptv\":\"both\",\r",
									"  \"condRsn\":\"Default Test Condition\",\r",
									"  \"ntty\":\r",
									"  {\r",
									"    \"id\": `${dbtrNttyId.id}`,\r",
									"    \"schmeNm\":\r",
									"    {\r",
									"      \"prtry\":\"TAZAMA_EID\"\r",
									"    }\r",
									"  },\r",
									"  \"forceCret\":true,\r",
									"  \"usr\":\"POSTMAN\"\r",
									"}\r",
									"\r",
									"// Set up body variables\r",
									"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
									"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{messageBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"{{path-entity-condition}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create New Entity Condition - Existing debtor entity",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"let conditionResult = responseJSON.result.conditions;\r",
									"let conditionEntity = responseJSON.result.ntty;\r",
									"let requestMessage = responseJSON.message;\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
									"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
									"let targetEntityId = nttyId + nttyIdSchme;\r",
									"\r",
									"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
									"targetRequestMessage = \"New condition was saved successfully.\"\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Result message matches target result message\", function () {\r",
									"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
									"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
									"    pm.expect(conditionResult.length).to.be.eql(1);\r",
									"});\r",
									"\r",
									"let firstElement = conditionResult[0];\r",
									"\r",
									"pm.test(\"Result condition has a non-empty condId\", function () {\r",
									"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
									"});\r",
									"\r",
									"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must have been defaulted\r",
									"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
									"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
									"    });\r",
									"}\r",
									"\r",
									"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must not have been defaulted\r",
									"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
									"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
									"    });\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
									"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
									"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
									"\r",
									"if (targetConditionResult.prsptv === \"both\") {\r",
									"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"};\r",
									"\r",
									"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
									"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
									"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
									"    });\r",
									"\r",
									"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
									"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"});\r",
									"\r",
									"const graphPostRequest = utils.getConditionsFromDBPostRequest('entities', targetEntityId);\r",
									"console.log(graphPostRequest);\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    let graphConditionList = utils.getConditionsFromGraph(graphConditionResult);\r",
									"\r",
									"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
									"        pm.expect(graphConditionList.length).to.eql(1);\r",
									"    });\r",
									"\r",
									"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
									"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
									"            pm.expect(graphConditionResult.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
									"    });\r",
									"\r",
									"    let edgeList = utils.getConditionPerspectivesFromGraph(graphConditionResult, graphConditionResult.v[0]._key);\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
									"    });\r",
									"\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Obliterate the current contents of the global variables\r",
									"pm.globals.set(\"pacs008\", undefined);\r",
									"pm.globals.set(\"dbtrNttyId\", undefined);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAcctId\", undefined);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAgt\", undefined);\r",
									"pm.globals.set(\"cdtrNttyId\", undefined);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAcctId\", undefined);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAgt\", undefined);\r",
									"\r",
									"// Set up the transaction (in memory only - nothing will exist in the DB yet)\r",
									"utils.createNewTransactionSet();\r",
									"\r",
									"// Retrieve the created pacs.008 message\r",
									"const submittedPacs008Message = JSON.parse(pm.globals.get(\"pacs008\"));\r",
									"\r",
									"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
									"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
									"\r",
									"// Load deconstructued identifier variables into global variables\r",
									"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"\r",
									"// Set up the condition\r",
									"\r",
									"messageBody = utils.getCreateEntityConditionBody(\r",
									"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
									"    /* Condition Type */ null,          // null defaults 'non-overridable-block'\r",
									"    /* Perspetive */ null,              // null defaults 'both'\r",
									"    /* Inception Date */ null,          // null defaults now()\r",
									"    /* Expiration Date */ null,         // null defaults now() + 24 hours\r",
									"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
									"    /* Entity */ dbtrNttyId,            // null defaults new unknown entity\r",
									"    /* Force Create */ false,           // null defaults true\r",
									"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
									");\r",
									"\r",
									"// Set up body variables\r",
									"pm.globals.set('messageBody', messageBody);\r",
									"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{messageBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"{{path-entity-condition}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Another New Entity Condition - Existing debtor entity",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"let conditionResult = responseJSON.result.conditions;\r",
									"let conditionEntity = responseJSON.result.ntty;\r",
									"let requestMessage = responseJSON.message;\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
									"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
									"let targetEntityId = nttyId + nttyIdSchme;\r",
									"\r",
									"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
									"targetRequestMessage = \"1 conditions already exist for the entity\"\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Result message matches target result message\", function () {\r",
									"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
									"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions array contains two conditions\", function () {\r",
									"    pm.expect(conditionResult.length).to.be.eql(2);\r",
									"});\r",
									"\r",
									"let newElement = conditionResult[conditionResult.length - 1];  // the last element is the newly submitted condition\r",
									"\r",
									"pm.test(\"Result condition has a non-empty condId\", function () {\r",
									"    pm.expect(newElement.condId).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
									"    pm.expect(newElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
									"});\r",
									"\r",
									"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(newElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must have been defaulted\r",
									"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
									"        pm.expect(newElement.incptnDtTm).to.exist.and.not.be.empty;\r",
									"    });\r",
									"}\r",
									"\r",
									"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(newElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must not have been defaulted\r",
									"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
									"        pm.expect(newElement.xprtnDtTm).to.not.exist;\r",
									"    });\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
									"    pm.expect(newElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
									"    pm.expect(newElement.usr).to.be.eql(targetConditionResult.usr);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
									"    pm.expect(newElement.creDtTm).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
									"let perspectives = newElement.prsptvs.map(({ prsptv }) => prsptv);\r",
									"\r",
									"if (targetConditionResult.prsptv === \"both\") {\r",
									"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
									"        pm.expect(newElement.prsptvs.length).to.be.eql(2);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"};\r",
									"\r",
									"for (let i = 0; i < newElement.prsptvs.length; i++) {   // for each perspective\r",
									"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
									"        pm.expect(newElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
									"    });\r",
									"\r",
									"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
									"        pm.expect(newElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
									"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.eql(newElement.incptnDtTm);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
									"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"});\r",
									"\r",
									"// Now we want to test that the data in the database matches the submitted data AND the response data\r",
									"\r",
									"const graphPostRequest = utils.getConditionsFromDBPostRequest('entities', targetEntityId);\r",
									"console.log(graphPostRequest);\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    let graphConditionList = utils.getConditionsFromGraph(graphConditionResult, \"all\");\r",
									"    let submittedCondition = graphConditionList.filter(condition => condition._id === `conditions/${newElement.condId}`);\r",
									"\r",
									"    // First we check that the submitted condition matches the database version\r",
									"\r",
									"    pm.test(`Only two conditions for entity [${targetEntityId}] exists in the database`, function () {\r",
									"        pm.expect(graphConditionList.length).to.eql(2);\r",
									"    });\r",
									"\r",
									"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
									"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
									"            pm.expect(submittedCondition[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
									"        pm.expect(submittedCondition[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
									"        pm.expect(submittedCondition[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(submittedCondition[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
									"            pm.expect(submittedCondition[0].incptnDtTm).to.exist.and.not.be.empty;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(submittedCondition[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
									"            pm.expect(submittedCondition[0].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
									"        pm.expect(submittedCondition[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
									"        pm.expect(submittedCondition[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"        pm.expect(submittedCondition[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
									"        pm.expect(submittedCondition[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
									"        pm.expect(submittedCondition[0].usr).to.be.eql(targetConditionResult.usr);\r",
									"    });\r",
									"\r",
									"    let edgeList = utils.getConditionPerspectivesFromGraph(graphConditionResult, submittedCondition[0]._key);\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
									"    });\r",
									"\r",
									"    // Then we check the previous conditions in the response one-by-one against the database version\r",
									"    let previousConditionsFromResponse = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
									"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
									"    let previousConditionsFromDatabase = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
									"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
									"\r",
									"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
									"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
									"    });\r",
									"\r",
									"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the reponse`, function () {\r",
									"        pm.expect(previousConditionsFromResponse.length).to.eql(1);\r",
									"    });\r",
									"\r",
									"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the database`, function () {\r",
									"        pm.expect(previousConditionsFromDatabase.length).to.eql(1);\r",
									"    });\r",
									"\r",
									"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
									"\r",
									"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
									"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
									"\r",
									"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
									"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
									"            });\r",
									"        }\r",
									"\r",
									"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
									"        });\r",
									"\r",
									"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
									"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
									"            });\r",
									"        } else {    // if not, one must have been defaulted\r",
									"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
									"            });\r",
									"        }\r",
									"\r",
									"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
									"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
									"            });\r",
									"        } else {    // if not, one must not have been defaulted\r",
									"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
									"            });\r",
									"        }\r",
									"\r",
									"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
									"        });\r",
									"\r",
									"        let edgeList = utils.getConditionPerspectivesFromGraph(graphConditionResult, justOneConditionFromResponse[0]._key);\r",
									"\r",
									"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
									"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
									"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
									"        });\r",
									"\r",
									"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
									"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
									"        });\r",
									"\r",
									"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
									"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
									"        });\r",
									"    }\r",
									"\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Retrieve the created pacs.008 message\r",
									"const submittedPacs008Message = JSON.parse(pm.globals.get(\"pacs008\"));\r",
									"\r",
									"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
									"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
									"\r",
									"// Load deconstructued identifier variables into global variables\r",
									"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"\r",
									"// Set up the condition\r",
									"\r",
									"messageBody = utils.getCreateEntityConditionBody(\r",
									"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
									"    /* Condition Type */ 'override',    // null defaults 'non-overridable-block'\r",
									"    /* Perspetive */ null,              // null defaults 'both'\r",
									"    /* Inception Date */ null,          // null defaults now()\r",
									"    /* Expiration Date */ null,         // null defaults now() + 24 hours\r",
									"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
									"    /* Entity */ dbtrNttyId,            // null defaults new unknown entity\r",
									"    /* Force Create */ false,           // null defaults true\r",
									"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
									");\r",
									"\r",
									"// Set up body variables\r",
									"pm.globals.set('messageBody', messageBody);\r",
									"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{messageBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"{{path-entity-condition}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Fetch Entity Conditions - Existing entity",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"let conditionResult = responseJSON.conditions;\r",
									"let conditionEntity = responseJSON.ntty;\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
									"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
									"let targetEntityId = nttyId + nttyIdSchme;\r",
									"\r",
									"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
									"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions array contains two conditions\", function () {\r",
									"    pm.expect(conditionResult.length).to.be.eql(2);\r",
									"});\r",
									"\r",
									"// We want to test that the data in the database matches the response data\r",
									"\r",
									"const graphPostRequest = utils.getConditionsFromDBPostRequest('entities', targetEntityId);\r",
									"console.log(graphPostRequest);\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    let graphConditionList = utils.getConditionsFromGraph(graphConditionResult, \"all\");\r",
									"\r",
									"    // Check the previous conditions in the response one-by-one against the database version\r",
									"    let previousConditionsFromResponse = graphConditionList;\r",
									"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
									"    let previousConditionsFromDatabase = graphConditionList;\r",
									"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
									"\r",
									"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
									"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
									"    });\r",
									"\r",
									"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the reponse`, function () {\r",
									"        pm.expect(previousConditionsFromResponse.length).to.eql(1);\r",
									"    });\r",
									"\r",
									"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the database`, function () {\r",
									"        pm.expect(previousConditionsFromDatabase.length).to.eql(1);\r",
									"    });\r",
									"\r",
									"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
									"\r",
									"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
									"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
									"\r",
									"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
									"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
									"            });\r",
									"        }\r",
									"\r",
									"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
									"        });\r",
									"\r",
									"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
									"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
									"            });\r",
									"        } else {    // if not, one must have been defaulted\r",
									"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
									"            });\r",
									"        }\r",
									"\r",
									"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
									"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
									"            });\r",
									"        } else {    // if not, one must not have been defaulted\r",
									"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
									"            });\r",
									"        }\r",
									"\r",
									"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
									"        });\r",
									"\r",
									"        let edgeList = utils.getConditionPerspectivesFromGraph(graphConditionResult, justOneConditionFromResponse[0]._key);\r",
									"\r",
									"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
									"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
									"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
									"        });\r",
									"\r",
									"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
									"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
									"        });\r",
									"\r",
									"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
									"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
									"        });\r",
									"    }\r",
									"\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Set up the entity and account attributes from a previously submitted pacs008\r",
									"pm.globals.set(\"dbtrNttyId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].Id);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].SchmeNm.Prtry);\r",
									"pm.globals.set(\"dbtrAcctId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].Id);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].SchmeNm.Prtry);\r",
									"pm.globals.set(\"dbtrAgt\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAgt.FinInstnId.ClrSysMmbId.MmbId);\r",
									"pm.globals.set(\"cdtrNttyId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0].Id);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0].SchmeNm.Prtry);\r",
									"pm.globals.set(\"cdtrAcctId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].Id);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].SchmeNm.Prtry);\r",
									"pm.globals.set(\"cdtrAgt\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAgt.FinInstnId.ClrSysMmbId.MmbId);\r",
									"\r",
									"pm.globals.set(\"synccache\", \"no\");"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/entity?id={{dbtrNttyId}}&schmenm={{dbtrNttyIdSchmeNm}}&synccache=no",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"admin",
								"event-flow-control",
								"entity"
							],
							"query": [
								{
									"key": "id",
									"value": "{{dbtrNttyId}}"
								},
								{
									"key": "schmenm",
									"value": "{{dbtrNttyIdSchmeNm}}"
								},
								{
									"key": "synccache",
									"value": "no"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Fetch Account Conditions",
			"item": [
				{
					"name": "Fetch Account Conditions - new account",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"No conditions returned\", function () {\r",
									"    pm.expect(responseJSON.conditions).to.be.an( \"array\" ).that.is.empty;\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"pm.globals.set(\"pacs008\", undefined);\r",
									"\r",
									"// Set up the transaction\r",
									"utils.createNewTransactionSet();\r",
									"\r",
									"pm.globals.set(\"dbtrNttyId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].Id);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].SchmeNm.Prtry);\r",
									"pm.globals.set(\"dbtrAcctId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].Id);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].SchmeNm.Prtry);\r",
									"pm.globals.set(\"dbtrAgt\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAgt.FinInstnId.ClrSysMmbId.MmbId);\r",
									"pm.globals.set(\"cdtrNttyId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0].Id);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0].SchmeNm.Prtry);\r",
									"pm.globals.set(\"cdtrAcctId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].Id);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].SchmeNm.Prtry);\r",
									"pm.globals.set(\"cdtrAgt\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAgt.FinInstnId.ClrSysMmbId.MmbId);\r",
									"\r",
									"pm.globals.set(\"synccache\", \"no\");"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache=no",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"admin",
								"event-flow-control",
								"account"
							],
							"query": [
								{
									"key": "id",
									"value": "{{dbtrAcctId}}"
								},
								{
									"key": "schmenm",
									"value": "{{dbtrAcctIdSchmeNm}}"
								},
								{
									"key": "agt",
									"value": "{{dbtrAgt}}"
								},
								{
									"key": "synccache",
									"value": "no"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Create New Account Condition - existing account",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"let conditionResult = responseJSON.condition;\r",
									"let requestMessage = responseJSON.message;\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"\r",
									"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
									"targetRequestMessage = \"New condition was saved successfully.\"\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Result message matches target result message\", function () {\r",
									"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.evtTp matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.evtTp).to.be.eql(targetConditionResult.evtTp);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.condTp).to.be.eql(targetConditionResult.condTp);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.prsptv matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.prsptv).to.be.eql(targetConditionResult.prsptv);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.acct.id matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.acct.id).to.be.eql(targetConditionResult.acct.id);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.acct.schmeNm.prtry).to.be.eql(targetConditionResult.acct.schmeNm.prtry);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.forceCret matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.forceCret).to.be.eql(targetConditionResult.forceCret);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.usr).to.be.eql(targetConditionResult.usr);\r",
									"});\r",
									"\r",
									"const qryGraphString = `LET vertices = (FOR v,e,p IN 1..2 ANY 'accounts/${targetConditionResult.acct.id + targetConditionResult.acct.schmeNm.prtry + targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId}' governed_as_debtor_by, governed_as_debtor_account_by, governed_as_creditor_by, governed_as_creditor_account_by RETURN distinct v) LET edges = (FOR v,e,p IN 1..2 ANY 'accounts/${targetConditionResult.acct.id + targetConditionResult.acct.schmeNm.prtry + targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId}' governed_as_debtor_by, governed_as_debtor_account_by, governed_as_creditor_by, governed_as_creditor_account_by RETURN distinct e) RETURN {v: vertices, e: edges}`\r",
									"\r",
									"const graphPostRequest = {\r",
									"    url: `${_pm.environment.get('arangoUrl')}/_db/${_pm.environment.get('db_historygraph')}/_api/cursor`,\r",
									"    method: 'POST',\r",
									"    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
									"    body: {\r",
									"        mode: 'raw',\r",
									"        raw: JSON.stringify({\r",
									"            query: qryGraphString\r",
									"        })\r",
									"    }\r",
									"};\r",
									"\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    pm.test(\"Only one condition exists in the database\", function () {\r",
									"        pm.expect(graphConditionResult.v.length).to.be.eql(2); // one for the account, one for the condition\r",
									"    });\r",
									"\r",
									"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
									"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
									"            pm.expect(graphConditionResult.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.acct.id matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].acct.id).to.be.eql(targetConditionResult.acct.id);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].acct.schmeNm.prtry).to.be.eql(targetConditionResult.acct.schmeNm.prtry);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
									"    });\r",
									"\r",
									"    let edgeList = [];\r",
									"    for (i = 0; i < graphConditionResult.e.length; i++) {\r",
									"        edgeList.push(graphConditionResult.e[i]._id.substring(0, graphConditionResult.e[i]._id.search('/')));\r",
									"    };\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_account_by\" edge exists`, function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_account_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_creditor_account_by\" edge exists`, function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_account_by\"]);\r",
									"    });\r",
									"\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Set up the transaction\r",
									"utils.createNewTransactionSet();\r",
									"\r",
									"let dbtrNtty = {\r",
									"    \"id\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].Id,\r",
									"    \"schmeNm\": {\r",
									"        \"prtry\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].SchmeNm.Prtry\r",
									"    }\r",
									"};\r",
									"let dbtrAcct = {\r",
									"    \"id\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].Id,\r",
									"    \"schmeNm\": {\r",
									"        \"prtry\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].SchmeNm.Prtry\r",
									"    },\r",
									"    \"agt\": {\r",
									"        \"finInstnId\": {\r",
									"            \"clrSysMmbId\": {\r",
									"                \"mmbId\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAgt.FinInstnId.ClrSysMmbId.MmbId\r",
									"            }\r",
									"        }\r",
									"    }\r",
									"};\r",
									"let cdtrNtty = JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0];\r",
									"let cdtrAcct = {\r",
									"    \"id\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].Id,\r",
									"    \"schmeNm\": {\r",
									"        \"prtry\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].SchmeNm.Prtry\r",
									"    },\r",
									"    \"agt\": {\r",
									"        \"finInstnId\": {\r",
									"            \"clrSysMmbId\": {\r",
									"                \"mmbId\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAgt.FinInstnId.ClrSysMmbId.MmbId\r",
									"            }\r",
									"        }\r",
									"    }\r",
									"};\r",
									"\r",
									"// Set up the condition\r",
									"\r",
									"messageBody = utils.getCreateAccountConditionBody(\r",
									"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
									"    /* Condition Type */ 'overridable-block',          // null defaults 'non-overridable-block'\r",
									"    /* Perspetive */ null,              // null defaults 'both''\r",
									"    /* Inception Date */ null,          // null defaults null\r",
									"    /* Expiration Date */ null,         // null defaults null\r",
									"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
									"    /* Account */ dbtrAcct,             // null defaults new unknown account on dfsp001\r",
									"    /* Force Create */ false,           // null defaults true\r",
									"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
									");\r",
									"\r",
									"// ## Set up body variables\r",
									"\r",
									"pm.globals.set('messageBody', messageBody);\r",
									"\r",
									"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{messageBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"{{path-account-condition}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Another New Account Condition - existing account",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"let conditionResult = responseJSON.condition;\r",
									"let requestMessage = responseJSON.message;\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"\r",
									"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
									"targetRequestMessage = \"New condition was saved successfully.\"\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Result message matches target result message\", function () {\r",
									"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.evtTp matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.evtTp).to.be.eql(targetConditionResult.evtTp);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.condTp).to.be.eql(targetConditionResult.condTp);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.prsptv matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.prsptv).to.be.eql(targetConditionResult.prsptv);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.acct.id matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.acct.id).to.be.eql(targetConditionResult.acct.id);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.acct.schmeNm.prtry).to.be.eql(targetConditionResult.acct.schmeNm.prtry);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.forceCret matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.forceCret).to.be.eql(targetConditionResult.forceCret);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.usr).to.be.eql(targetConditionResult.usr);\r",
									"});\r",
									"\r",
									"const qryGraphString = `LET vertices = (FOR v,e,p IN 1..2 ANY 'accounts/${targetConditionResult.acct.id + targetConditionResult.acct.schmeNm.prtry + targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId}' governed_as_debtor_by, governed_as_debtor_account_by, governed_as_creditor_by, governed_as_creditor_account_by RETURN distinct v) LET edges = (FOR v,e,p IN 1..2 ANY 'accounts/${targetConditionResult.acct.id + targetConditionResult.acct.schmeNm.prtry + targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId}' governed_as_debtor_by, governed_as_debtor_account_by, governed_as_creditor_by, governed_as_creditor_account_by RETURN distinct e) RETURN {v: vertices, e: edges}`\r",
									"\r",
									"const graphPostRequest = {\r",
									"    url: `${_pm.environment.get('arangoUrl')}/_db/${_pm.environment.get('db_historygraph')}/_api/cursor`,\r",
									"    method: 'POST',\r",
									"    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
									"    body: {\r",
									"        mode: 'raw',\r",
									"        raw: JSON.stringify({\r",
									"            query: qryGraphString\r",
									"        })\r",
									"    }\r",
									"};\r",
									"\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    pm.test(\"Only one condition exists in the database\", function () {\r",
									"        pm.expect(graphConditionResult.v.length).to.be.eql(2); // one for the account, one for the condition\r",
									"    });\r",
									"\r",
									"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
									"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
									"            pm.expect(graphConditionResult.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.acct.id matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].acct.id).to.be.eql(targetConditionResult.acct.id);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].acct.schmeNm.prtry).to.be.eql(targetConditionResult.acct.schmeNm.prtry);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
									"    });\r",
									"\r",
									"    let edgeList = [];\r",
									"    for (i = 0; i < graphConditionResult.e.length; i++) {\r",
									"        edgeList.push(graphConditionResult.e[i]._id.substring(0, graphConditionResult.e[i]._id.search('/')));\r",
									"    };\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_account_by\" edge exists`, function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_account_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_creditor_account_by\" edge exists`, function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_account_by\"]);\r",
									"    });\r",
									"\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Set up the transaction\r",
									"utils.createNewTransactionSet();\r",
									"\r",
									"let dbtrNtty = {\r",
									"    \"id\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].Id,\r",
									"    \"schmeNm\": {\r",
									"        \"prtry\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].SchmeNm.Prtry\r",
									"    }\r",
									"};\r",
									"let dbtrAcct = {\r",
									"    \"id\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].Id,\r",
									"    \"schmeNm\": {\r",
									"        \"prtry\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].SchmeNm.Prtry\r",
									"    },\r",
									"    \"agt\": {\r",
									"        \"finInstnId\": {\r",
									"            \"clrSysMmbId\": {\r",
									"                \"mmbId\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAgt.FinInstnId.ClrSysMmbId.MmbId\r",
									"            }\r",
									"        }\r",
									"    }\r",
									"};\r",
									"let cdtrNtty = JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0];\r",
									"let cdtrAcct = {\r",
									"    \"id\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].Id,\r",
									"    \"schmeNm\": {\r",
									"        \"prtry\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].SchmeNm.Prtry\r",
									"    },\r",
									"    \"agt\": {\r",
									"        \"finInstnId\": {\r",
									"            \"clrSysMmbId\": {\r",
									"                \"mmbId\": JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAgt.FinInstnId.ClrSysMmbId.MmbId\r",
									"            }\r",
									"        }\r",
									"    }\r",
									"};\r",
									"\r",
									"// Set up the condition\r",
									"\r",
									"messageBody = utils.getCreateAccountConditionBody(\r",
									"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
									"    /* Condition Type */ 'override',          // null defaults 'non-overridable-block'\r",
									"    /* Perspetive */ null,              // null defaults 'both''\r",
									"    /* Inception Date */ null,          // null defaults null\r",
									"    /* Expiration Date */ null,         // null defaults null\r",
									"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
									"    /* Account */ dbtrAcct,             // null defaults new unknown account on dfsp001\r",
									"    /* Force Create */ false,           // null defaults true\r",
									"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
									");\r",
									"\r",
									"// ## Set up body variables\r",
									"\r",
									"pm.globals.set('messageBody', messageBody);\r",
									"\r",
									"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{messageBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"{{path-account-condition}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Fetch Account Conditions - Existing",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"let conditionResult = responseJSON.condition;\r",
									"let requestMessage = responseJSON.message;\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"\r",
									"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
									"targetRequestMessage = \"New condition was saved successfully.\"\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Result message matches target result message\", function () {\r",
									"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.evtTp matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.evtTp).to.be.eql(targetConditionResult.evtTp);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.condTp).to.be.eql(targetConditionResult.condTp);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.prsptv matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.prsptv).to.be.eql(targetConditionResult.prsptv);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.ntty.id matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.forceCret matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.forceCret).to.be.eql(targetConditionResult.forceCret);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
									"    pm.expect(conditionResult.usr).to.be.eql(targetConditionResult.usr);\r",
									"});\r",
									"\r",
									"const qryGraphString = `LET vertices = (FOR v,e,p IN 1..2 ANY 'entities/${targetConditionResult.ntty.id + targetConditionResult.ntty.schmeNm.prtry}' governed_as_debtor_by, governed_as_debtor_account_by, governed_as_creditor_by, governed_as_creditor_account_by RETURN distinct v) LET edges = (FOR v,e,p IN 1..2 ANY 'entities/${targetConditionResult.ntty.id + targetConditionResult.ntty.schmeNm.prtry}' governed_as_debtor_by, governed_as_debtor_account_by, governed_as_creditor_by, governed_as_creditor_account_by RETURN distinct e) RETURN {v: vertices, e: edges}`\r",
									"\r",
									"const graphPostRequest = {\r",
									"    url: `${_pm.environment.get('arangoUrl')}/_db/${_pm.environment.get('db_historygraph')}/_api/cursor`,\r",
									"    method: 'POST',\r",
									"    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
									"    body: {\r",
									"        mode: 'raw',\r",
									"        raw: JSON.stringify({\r",
									"            query: qryGraphString\r",
									"        })\r",
									"    }\r",
									"};\r",
									"\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    pm.test(\"Only one condition exists in the database\", function () {\r",
									"        pm.expect(graphConditionResult.v.length).to.be.eql(2); // one for the entity, one for the condition\r",
									"    });\r",
									"\r",
									"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
									"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
									"            pm.expect(graphConditionResult.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
									"    });\r",
									"\r",
									"    let edgeList = [];\r",
									"    for (i = 0; i < graphConditionResult.e.length; i++) {\r",
									"        edgeList.push(graphConditionResult.e[i]._id.substring(0, graphConditionResult.e[i]._id.search('/')));\r",
									"    };\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
									"    });\r",
									"\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Set up the entity and account attributes from a previously submitted pacs008\r",
									"pm.globals.set(\"dbtrNttyId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].Id);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].SchmeNm.Prtry);\r",
									"pm.globals.set(\"dbtrAcctId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].Id);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].SchmeNm.Prtry);\r",
									"pm.globals.set(\"dbtrAgt\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAgt.FinInstnId.ClrSysMmbId.MmbId);\r",
									"pm.globals.set(\"cdtrNttyId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0].Id);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0].SchmeNm.Prtry);\r",
									"pm.globals.set(\"cdtrAcctId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].Id);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].SchmeNm.Prtry);\r",
									"pm.globals.set(\"cdtrAgt\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAgt.FinInstnId.ClrSysMmbId.MmbId);\r",
									"\r",
									"pm.globals.set(\"synccache\", \"no\");"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account/getconditions?id={{dbtrAcctId}}&schmeNm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&syncCache=no",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"admin",
								"event-flow-control",
								"account",
								"getconditions"
							],
							"query": [
								{
									"key": "id",
									"value": "{{dbtrAcctId}}"
								},
								{
									"key": "schmeNm",
									"value": "{{dbtrAcctIdSchmeNm}}"
								},
								{
									"key": "agt",
									"value": "{{dbtrAgt}}"
								},
								{
									"key": "syncCache",
									"value": "no"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Entity Conditions",
			"item": [
				{
					"name": "Fetch Entity Conditions - new debtor entity",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"let conditionResult = responseJSON.conditions;\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Result is an empty conditions array\", function () {\r",
									"    pm.expect(responseJSON.conditions).to.be.an( \"array\" ).that.is.empty;\r",
									"});\r",
									"\r",
									"const targetEntityId = pm.globals.get(\"cdtrNttyId\") + pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
									"const graphPostRequest = utils.getConditionsFromDBPostRequest('entities', targetEntityId);\r",
									"console.log(graphPostRequest);\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    let graphConditionList = utils.getConditionsFromGraph(graphConditionResult);\r",
									"\r",
									"    pm.test(`No conditions for entity [${targetEntityId}] exists in the database`, function () {\r",
									"        pm.expect(graphConditionList.length).to.eql(0);\r",
									"    });\r",
									"\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Obliterate the current contents of the pacs008 global variable\r",
									"pm.globals.set(\"pacs008\", undefined);\r",
									"pm.globals.set(\"dbtrNttyId\", undefined);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAcctId\", undefined);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAgt\", undefined);\r",
									"pm.globals.set(\"cdtrNttyId\", undefined);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAcctId\", undefined);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAgt\", undefined);\r",
									"\r",
									"// Set up the transaction (in memory and in the databases)\r",
									"utils.createNewTransactionSetInMemory();\r",
									"\r",
									"// Retrieve the created pacs.008 message\r",
									"const submittedPacs008Message = JSON.parse(pm.globals.get(\"pacs008\"));\r",
									"\r",
									"// Create identifier variables from the pacs.008 message\r",
									"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
									"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
									"\r",
									"// Load deconstructued identifier variables into global variables\r",
									"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"\r",
									"pm.globals.set(\"syncCache\", \"no\");"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/entity?id={{dbtrNttyId}}&schmenm={{cdtrNttyIdSchmeNm}}&synccache={{syncCache}}",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"admin",
								"event-flow-control",
								"entity"
							],
							"query": [
								{
									"key": "id",
									"value": "{{dbtrNttyId}}"
								},
								{
									"key": "schmenm",
									"value": "{{cdtrNttyIdSchmeNm}}"
								},
								{
									"key": "synccache",
									"value": "{{syncCache}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Create New Entity Condition - Unknown debtor entity",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"let conditionResult = responseJSON.result.conditions;\r",
									"let conditionEntity = responseJSON.result.ntty;\r",
									"let requestMessage = responseJSON.message;\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
									"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
									"let targetEntityId = nttyId + nttyIdSchme;\r",
									"\r",
									"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
									"targetRequestMessage = \"New condition was saved successfully.\"\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Result message matches target result message\", function () {\r",
									"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
									"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
									"    pm.expect(conditionResult.length).to.be.eql(1);\r",
									"});\r",
									"\r",
									"let firstElement = conditionResult[0];\r",
									"\r",
									"pm.test(\"Result condition has a non-empty condId\", function () {\r",
									"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
									"});\r",
									"\r",
									"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must have been defaulted\r",
									"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
									"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
									"    });\r",
									"}\r",
									"\r",
									"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must not have been defaulted\r",
									"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
									"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
									"    });\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
									"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
									"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
									"\r",
									"if (targetConditionResult.prsptv === \"both\") {\r",
									"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"};\r",
									"\r",
									"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
									"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
									"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
									"    });\r",
									"\r",
									"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
									"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"});\r",
									"\r",
									"const graphPostRequest = utils.getConditionsFromDBPostRequest('entities', targetEntityId);\r",
									"console.log(graphPostRequest);\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    let graphConditionList = utils.getConditionsFromGraph(graphConditionResult);\r",
									"\r",
									"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
									"        pm.expect(graphConditionList.length).to.eql(1);\r",
									"    });\r",
									"\r",
									"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
									"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
									"            pm.expect(graphConditionResult.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
									"    });\r",
									"\r",
									"    let edgeList = utils.getConditionPerspectivesFromGraph(graphConditionResult, graphConditionResult.v[0]._key);\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
									"    });\r",
									"\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Obliterate the current contents of the global variables\r",
									"pm.globals.set(\"pacs008\", undefined);\r",
									"pm.globals.set(\"dbtrNttyId\", undefined);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAcctId\", undefined);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAgt\", undefined);\r",
									"pm.globals.set(\"cdtrNttyId\", undefined);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAcctId\", undefined);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAgt\", undefined);\r",
									"\r",
									"// Set up the transaction (in memory only - nothing will exist in the DB yet)\r",
									"utils.createNewTransactionSetInMemory();\r",
									"\r",
									"// Retrieve the created pacs.008 message\r",
									"const submittedPacs008Message = JSON.parse(pm.globals.get(\"pacs008\"));\r",
									"\r",
									"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
									"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
									"\r",
									"// Load deconstructued identifier variables into global variables\r",
									"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"\r",
									"// Set up the condition\r",
									"\r",
									"messageBody = utils.getCreateEntityConditionBody(\r",
									"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
									"    /* Condition Type */ null,          // null defaults 'non-overridable-block'\r",
									"    /* Perspetive */ null,              // null defaults 'both'\r",
									"    /* Inception Date */ null,          // null defaults now()\r",
									"    /* Expiration Date */ null,         // null defaults now() + 24 hours\r",
									"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
									"    /* Entity */ dbtrNttyId,            // null defaults new unknown entity\r",
									"    /* Force Create */ false,           // null defaults true\r",
									"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
									");\r",
									"\r",
									"// Set up body variables\r",
									"pm.globals.set('messageBody', messageBody);\r",
									"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{messageBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"{{path-entity-condition}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create New Entity Condition Manually - Unknown debtor entity",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"let conditionResult = responseJSON.result.conditions;\r",
									"let conditionEntity = responseJSON.result.ntty;\r",
									"let requestMessage = responseJSON.message;\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
									"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
									"let targetEntityId = nttyId + nttyIdSchme;\r",
									"\r",
									"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
									"targetRequestMessage = \"New condition was saved successfully.\"\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Result message matches target result message\", function () {\r",
									"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
									"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
									"    pm.expect(conditionResult.length).to.be.eql(1);\r",
									"});\r",
									"\r",
									"let firstElement = conditionResult[0];\r",
									"\r",
									"pm.test(\"Result condition has a non-empty condId\", function () {\r",
									"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
									"});\r",
									"\r",
									"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must have been defaulted\r",
									"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
									"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
									"    });\r",
									"}\r",
									"\r",
									"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must not have been defaulted\r",
									"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
									"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
									"    });\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
									"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
									"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
									"\r",
									"if (targetConditionResult.prsptv === \"both\") {\r",
									"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"};\r",
									"\r",
									"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
									"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
									"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
									"    });\r",
									"\r",
									"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
									"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"});\r",
									"\r",
									"const graphPostRequest = utils.getConditionsFromDBPostRequest('entities', targetEntityId);\r",
									"console.log(graphPostRequest);\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    let graphConditionList = utils.getConditionsFromGraph(graphConditionResult);\r",
									"\r",
									"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
									"        pm.expect(graphConditionList.length).to.eql(1);\r",
									"    });\r",
									"\r",
									"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
									"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
									"            pm.expect(graphConditionResult.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
									"    });\r",
									"\r",
									"    let edgeList = utils.getConditionPerspectivesFromGraph(graphConditionResult, graphConditionResult.v[0]._key);\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
									"    });\r",
									"\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Obliterate the current contents of the global variables\r",
									"pm.globals.set(\"pacs008\", undefined);\r",
									"pm.globals.set(\"dbtrNttyId\", undefined);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAcctId\", undefined);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAgt\", undefined);\r",
									"pm.globals.set(\"cdtrNttyId\", undefined);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAcctId\", undefined);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAgt\", undefined);\r",
									"\r",
									"// Set up the transaction (in memory only - nothing will exist in the DB yet)\r",
									"utils.createNewTransactionSetInMemory();\r",
									"\r",
									"// Retrieve the created pacs.008 message\r",
									"const submittedPacs008Message = JSON.parse(pm.globals.get(\"pacs008\"));\r",
									"\r",
									"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
									"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
									"\r",
									"// Load deconstructued identifier variables into global variables\r",
									"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"\r",
									"// Set up the condition\r",
									"\r",
									"messageBody = {\r",
									"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
									"  \"condTp\":\"non-overridable-block\",\r",
									"  \"prsptv\":\"both\",\r",
									"  \"condRsn\":\"Default Test Condition\",\r",
									"  \"ntty\":\r",
									"  {\r",
									"    \"id\": `${dbtrNttyId.id}`,\r",
									"    \"schmeNm\":\r",
									"    {\r",
									"      \"prtry\":\"TAZAMA_EID\"\r",
									"    }\r",
									"  },\r",
									"  \"forceCret\":true,\r",
									"  \"usr\":\"POSTMAN\"\r",
									"}\r",
									"\r",
									"// Set up body variables\r",
									"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
									"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{messageBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"{{path-entity-condition}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create New Entity Condition - Existing debtor entity",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"let conditionResult = responseJSON.result.conditions;\r",
									"let conditionEntity = responseJSON.result.ntty;\r",
									"let requestMessage = responseJSON.message;\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
									"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
									"let targetEntityId = nttyId + nttyIdSchme;\r",
									"\r",
									"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
									"targetRequestMessage = \"New condition was saved successfully.\"\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Result message matches target result message\", function () {\r",
									"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
									"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
									"    pm.expect(conditionResult.length).to.be.eql(1);\r",
									"});\r",
									"\r",
									"let firstElement = conditionResult[0];\r",
									"\r",
									"pm.test(\"Result condition has a non-empty condId\", function () {\r",
									"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
									"});\r",
									"\r",
									"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must have been defaulted\r",
									"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
									"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
									"    });\r",
									"}\r",
									"\r",
									"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must not have been defaulted\r",
									"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
									"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
									"    });\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
									"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
									"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
									"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
									"\r",
									"if (targetConditionResult.prsptv === \"both\") {\r",
									"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"};\r",
									"\r",
									"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
									"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
									"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
									"    });\r",
									"\r",
									"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
									"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
									"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"});\r",
									"\r",
									"const graphPostRequest = utils.getConditionsFromDBPostRequest('entities', targetEntityId);\r",
									"console.log(graphPostRequest);\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    let graphConditionList = utils.getConditionsFromGraph(graphConditionResult);\r",
									"\r",
									"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
									"        pm.expect(graphConditionList.length).to.eql(1);\r",
									"    });\r",
									"\r",
									"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
									"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
									"            pm.expect(graphConditionResult.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
									"            pm.expect(graphConditionResult.v[0].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
									"        pm.expect(graphConditionResult.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
									"    });\r",
									"\r",
									"    let edgeList = utils.getConditionPerspectivesFromGraph(graphConditionResult, graphConditionResult.v[0]._key);\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
									"    });\r",
									"\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Obliterate the current contents of the global variables\r",
									"pm.globals.set(\"pacs008\", undefined);\r",
									"pm.globals.set(\"dbtrNttyId\", undefined);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAcctId\", undefined);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAgt\", undefined);\r",
									"pm.globals.set(\"cdtrNttyId\", undefined);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAcctId\", undefined);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAgt\", undefined);\r",
									"\r",
									"// Set up the transaction (in memory only - nothing will exist in the DB yet)\r",
									"utils.createNewTransactionSet();\r",
									"\r",
									"// Retrieve the created pacs.008 message\r",
									"const submittedPacs008Message = JSON.parse(pm.globals.get(\"pacs008\"));\r",
									"\r",
									"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
									"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
									"\r",
									"// Load deconstructued identifier variables into global variables\r",
									"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"\r",
									"// Set up the condition\r",
									"\r",
									"messageBody = utils.getCreateEntityConditionBody(\r",
									"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
									"    /* Condition Type */ null,          // null defaults 'non-overridable-block'\r",
									"    /* Perspetive */ null,              // null defaults 'both'\r",
									"    /* Inception Date */ null,          // null defaults now()\r",
									"    /* Expiration Date */ null,         // null defaults now() + 24 hours\r",
									"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
									"    /* Entity */ dbtrNttyId,            // null defaults new unknown entity\r",
									"    /* Force Create */ false,           // null defaults true\r",
									"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
									");\r",
									"\r",
									"// Set up body variables\r",
									"pm.globals.set('messageBody', messageBody);\r",
									"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{messageBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"{{path-entity-condition}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Another New Entity Condition - Existing debtor entity",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"let conditionResult = responseJSON.result.conditions;\r",
									"let conditionEntity = responseJSON.result.ntty;\r",
									"let requestMessage = responseJSON.message;\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
									"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
									"let targetEntityId = nttyId + nttyIdSchme;\r",
									"\r",
									"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
									"targetRequestMessage = \"1 conditions already exist for the entity\"\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Result message matches target result message\", function () {\r",
									"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
									"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions array contains two conditions\", function () {\r",
									"    pm.expect(conditionResult.length).to.be.eql(2);\r",
									"});\r",
									"\r",
									"let newElement = conditionResult[conditionResult.length - 1];  // the last element is the newly submitted condition\r",
									"\r",
									"pm.test(\"Result condition has a non-empty condId\", function () {\r",
									"    pm.expect(newElement.condId).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
									"    pm.expect(newElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
									"});\r",
									"\r",
									"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(newElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must have been defaulted\r",
									"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
									"        pm.expect(newElement.incptnDtTm).to.exist.and.not.be.empty;\r",
									"    });\r",
									"}\r",
									"\r",
									"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
									"        pm.expect(newElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"    });\r",
									"} else {    // if not, one must not have been defaulted\r",
									"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
									"        pm.expect(newElement.xprtnDtTm).to.not.exist;\r",
									"    });\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
									"    pm.expect(newElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
									"    pm.expect(newElement.usr).to.be.eql(targetConditionResult.usr);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
									"    pm.expect(newElement.creDtTm).to.exist.and.not.be.empty;\r",
									"});\r",
									"\r",
									"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
									"let perspectives = newElement.prsptvs.map(({ prsptv }) => prsptv);\r",
									"\r",
									"if (targetConditionResult.prsptv === \"both\") {\r",
									"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
									"        pm.expect(newElement.prsptvs.length).to.be.eql(2);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
									"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
									"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
									"    });\r",
									"\r",
									"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
									"\r",
									"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
									"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
									"    });\r",
									"\r",
									"};\r",
									"\r",
									"for (let i = 0; i < newElement.prsptvs.length; i++) {   // for each perspective\r",
									"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
									"        pm.expect(newElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
									"    });\r",
									"\r",
									"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
									"        pm.expect(newElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
									"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.eql(newElement.incptnDtTm);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
									"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
									"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"}\r",
									"\r",
									"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"});\r",
									"\r",
									"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"});\r",
									"\r",
									"// Now we want to test that the data in the database matches the submitted data AND the response data\r",
									"\r",
									"const graphPostRequest = utils.getConditionsFromDBPostRequest('entities', targetEntityId);\r",
									"console.log(graphPostRequest);\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    let graphConditionList = utils.getConditionsFromGraph(graphConditionResult, \"all\");\r",
									"    let submittedCondition = graphConditionList.filter(condition => condition._id === `conditions/${newElement.condId}`);\r",
									"\r",
									"    // First we check that the submitted condition matches the database version\r",
									"\r",
									"    pm.test(`Only two conditions for entity [${targetEntityId}] exists in the database`, function () {\r",
									"        pm.expect(graphConditionList.length).to.eql(2);\r",
									"    });\r",
									"\r",
									"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
									"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
									"            pm.expect(submittedCondition[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
									"        pm.expect(submittedCondition[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
									"        pm.expect(submittedCondition[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
									"    });\r",
									"\r",
									"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
									"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(submittedCondition[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must have been defaulted\r",
									"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
									"            pm.expect(submittedCondition[0].incptnDtTm).to.exist.and.not.be.empty;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
									"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
									"            pm.expect(submittedCondition[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
									"        });\r",
									"    } else {    // if not, one must not have been defaulted\r",
									"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
									"            pm.expect(submittedCondition[0].xprtnDtTm).to.not.exist;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
									"        pm.expect(submittedCondition[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
									"        pm.expect(submittedCondition[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"        pm.expect(submittedCondition[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
									"        pm.expect(submittedCondition[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
									"        pm.expect(submittedCondition[0].usr).to.be.eql(targetConditionResult.usr);\r",
									"    });\r",
									"\r",
									"    let edgeList = utils.getConditionPerspectivesFromGraph(graphConditionResult, submittedCondition[0]._key);\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
									"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
									"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
									"    });\r",
									"\r",
									"    // Then we check the previous conditions in the response one-by-one against the database version\r",
									"    let previousConditionsFromResponse = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
									"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
									"    let previousConditionsFromDatabase = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
									"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
									"\r",
									"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
									"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
									"    });\r",
									"\r",
									"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the reponse`, function () {\r",
									"        pm.expect(previousConditionsFromResponse.length).to.eql(1);\r",
									"    });\r",
									"\r",
									"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the database`, function () {\r",
									"        pm.expect(previousConditionsFromDatabase.length).to.eql(1);\r",
									"    });\r",
									"\r",
									"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
									"\r",
									"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
									"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
									"\r",
									"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
									"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
									"            });\r",
									"        }\r",
									"\r",
									"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
									"        });\r",
									"\r",
									"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
									"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
									"            });\r",
									"        } else {    // if not, one must have been defaulted\r",
									"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
									"            });\r",
									"        }\r",
									"\r",
									"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
									"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
									"            });\r",
									"        } else {    // if not, one must not have been defaulted\r",
									"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
									"            });\r",
									"        }\r",
									"\r",
									"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
									"        });\r",
									"\r",
									"        let edgeList = utils.getConditionPerspectivesFromGraph(graphConditionResult, justOneConditionFromResponse[0]._key);\r",
									"\r",
									"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
									"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
									"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
									"        });\r",
									"\r",
									"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
									"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
									"        });\r",
									"\r",
									"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
									"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
									"        });\r",
									"    }\r",
									"\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Retrieve the created pacs.008 message\r",
									"const submittedPacs008Message = JSON.parse(pm.globals.get(\"pacs008\"));\r",
									"\r",
									"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
									"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
									"\r",
									"// Load deconstructued identifier variables into global variables\r",
									"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"\r",
									"// Set up the condition\r",
									"\r",
									"messageBody = utils.getCreateEntityConditionBody(\r",
									"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
									"    /* Condition Type */ 'override',    // null defaults 'non-overridable-block'\r",
									"    /* Perspetive */ null,              // null defaults 'both'\r",
									"    /* Inception Date */ null,          // null defaults now()\r",
									"    /* Expiration Date */ null,         // null defaults now() + 24 hours\r",
									"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
									"    /* Entity */ dbtrNttyId,            // null defaults new unknown entity\r",
									"    /* Force Create */ false,           // null defaults true\r",
									"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
									");\r",
									"\r",
									"// Set up body variables\r",
									"pm.globals.set('messageBody', messageBody);\r",
									"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{messageBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"{{path-entity-condition}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Fetch Entity Conditions - Existing debtor entity",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJSON = pm.response.json();\r",
									"let conditionResult = responseJSON.conditions;\r",
									"pm.globals.set(\"conditions\", undefined); // obliterate current stashed conditions\r",
									"pm.globals.set(\"conditions\", JSON.stringify(conditionResult)); // stash response for future retrieval\r",
									"let conditionEntity = responseJSON.ntty;\r",
									"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
									"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
									"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
									"let targetEntityId = nttyId + nttyIdSchme;\r",
									"\r",
									"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
									"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Result conditions array contains two conditions\", function () {\r",
									"    pm.expect(conditionResult.length).to.be.eql(2);\r",
									"});\r",
									"\r",
									"// We want to test that the data in the database matches the response data\r",
									"\r",
									"const graphPostRequest = utils.getConditionsFromDBPostRequest('entities', targetEntityId);\r",
									"console.log(graphPostRequest);\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    let graphConditionList = utils.getConditionsFromGraph(graphConditionResult, \"all\");\r",
									"\r",
									"    // Check the previous conditions in the response one-by-one against the database version\r",
									"    let previousConditionsFromResponse = graphConditionList;\r",
									"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
									"    let previousConditionsFromDatabase = graphConditionList;\r",
									"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
									"\r",
									"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
									"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
									"    });\r",
									"\r",
									"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the reponse`, function () {\r",
									"        pm.expect(previousConditionsFromResponse.length).to.eql(2);\r",
									"    });\r",
									"\r",
									"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the database`, function () {\r",
									"        pm.expect(previousConditionsFromDatabase.length).to.eql(2);\r",
									"    });\r",
									"\r",
									"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
									"\r",
									"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
									"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
									"\r",
									"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
									"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
									"            });\r",
									"        }\r",
									"\r",
									"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
									"        });\r",
									"\r",
									"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
									"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
									"            });\r",
									"        } else {    // if not, one must have been defaulted\r",
									"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
									"            });\r",
									"        }\r",
									"\r",
									"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
									"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
									"            });\r",
									"        } else {    // if not, one must not have been defaulted\r",
									"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
									"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
									"            });\r",
									"        }\r",
									"\r",
									"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
									"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
									"        });\r",
									"\r",
									"        let edgeList = utils.getConditionPerspectivesFromGraph(graphConditionResult, justOneConditionFromResponse[0]._key);\r",
									"\r",
									"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
									"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
									"        });\r",
									"\r",
									"        pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
									"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
									"        });\r",
									"\r",
									"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
									"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
									"        });\r",
									"\r",
									"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
									"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
									"        });\r",
									"    }\r",
									"\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Obliterate the current contents of the pacs008 global variable\r",
									"pm.globals.set(\"dbtrNttyId\", undefined);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAcctId\", undefined);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAgt\", undefined);\r",
									"pm.globals.set(\"cdtrNttyId\", undefined);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAcctId\", undefined);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAgt\", undefined);\r",
									"\r",
									"// Retrieve the created pacs.008 message\r",
									"const submittedPacs008Message = JSON.parse(pm.globals.get(\"pacs008\"));\r",
									"\r",
									"// Create identifier variables from the pacs.008 message\r",
									"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
									"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
									"\r",
									"// Load deconstructued identifier variables into global variables\r",
									"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"\r",
									"pm.globals.set(\"syncCache\", \"no\");"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/entity?id={{dbtrNttyId}}&schmenm={{dbtrNttyIdSchmeNm}}&synccache=no",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"admin",
								"event-flow-control",
								"entity"
							],
							"query": [
								{
									"key": "id",
									"value": "{{dbtrNttyId}}"
								},
								{
									"key": "schmenm",
									"value": "{{dbtrNttyIdSchmeNm}}"
								},
								{
									"key": "synccache",
									"value": "no"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Update Entity Condition - Existing condition",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
									"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
									"let targetEntityId = nttyId + nttyIdSchme;\r",
									"let targetConditionId = pm.globals.get(\"condId\");\r",
									"let targetXprtnDtTm = JSON.parse(pm.globals.get(\"messageBody\")).xprtnDtTm;\r",
									"let targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"// We want to test that the condition in the database is updated\r",
									"\r",
									"const graphPostRequest = utils.getConditionsFromDBPostRequest('entities', targetEntityId);\r",
									"console.log(graphPostRequest);\r",
									"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
									"    console.log(error ? error : response.json());\r",
									"    graphConditionResult = response.json().result[0];\r",
									"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
									"\r",
									"    let graphConditionList = utils.getConditionsFromGraph(graphConditionResult, \"all\");\r",
									"    let updatedCondition = graphConditionList.filter(condition => condition._id === `conditions/${targetConditionId}`);\r",
									"    let nonUpdatedConditions = graphConditionList.filter(condition => condition._id != `conditions/${targetConditionId}`);\r",
									"\r",
									"    pm.test(`The xprntDtTm in condId ${targetConditionId} has been updated to ${targetXprtnDtTm}`, function () {\r",
									"        pm.expect(updatedCondition[0].xprtnDtTm).to.eql(targetXprtnDtTm);\r",
									"    });\r",
									"\r",
									"    pm.test(`No other condition xprtnDtTm is updated`, function () {\r",
									"        pm.expect(nonUpdatedConditions.filter(cond => cond.xprtnDtTm === targetXprtnDtTm).length).to.eql(0);\r",
									"    });\r",
									"\r",
									"    let perspectives = utils.getConditionPerspectivesFromGraph(graphConditionResult, updatedCondition[0]._key, \"all\");\r",
									"\r",
									"    // Check that the edges are updated\r",
									"    for (let i = 0; i < perspectives.length; i++) {\r",
									"        pm.test(`The xprntDtTm in condId ${targetConditionId} for perspective ${perspectives[i]._id} has been updated to ${targetXprtnDtTm}`, function () {\r",
									"            pm.expect(perspectives[i].xprtnDtTm).to.eql(targetXprtnDtTm);\r",
									"        });\r",
									"    }\r",
									"\r",
									"    // Check that none of the other edges have been updated\r",
									"    for (let i = 0; i < nonUpdatedConditions.length; i++) {\r",
									"\r",
									"        perspectives = utils.getConditionPerspectivesFromGraph(graphConditionResult, nonUpdatedConditions[i]._key, \"all\");\r",
									"\r",
									"        // Check that the other edges are not updated\r",
									"        for (let j = 0; j < perspectives.length; j++) {\r",
									"            pm.test(`The xprntDtTm in condId ${nonUpdatedConditions[i]._key} for perspective ${perspectives[j]._id} has not been updated to ${targetXprtnDtTm}`, function () {\r",
									"                pm.expect(perspectives.xprtnDtTm).to.not.eql(targetXprtnDtTm);\r",
									"            });\r",
									"        }\r",
									"    }\r",
									"\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
									"\r",
									"// Obliterate the current contents of the pacs008 global variable\r",
									"pm.globals.set(\"dbtrNttyId\", undefined);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAcctId\", undefined);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"dbtrAgt\", undefined);\r",
									"pm.globals.set(\"cdtrNttyId\", undefined);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAcctId\", undefined);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", undefined);\r",
									"pm.globals.set(\"cdtrAgt\", undefined);\r",
									"\r",
									"// Retrieve the created pacs.008 message\r",
									"const submittedPacs008Message = JSON.parse(pm.globals.get(\"pacs008\"));\r",
									"\r",
									"// Create identifier variables from the pacs.008 message\r",
									"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
									"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
									"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
									"\r",
									"// Load deconstructued identifier variables into global variables\r",
									"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
									"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
									"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
									"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
									"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
									"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
									"\r",
									"pm.globals.set(\"syncCache\", \"no\");\r",
									"\r",
									"// Fetch stashed conditions\r",
									"const conditions = JSON.parse(pm.globals.get(\"conditions\"));\r",
									"\r",
									"// Select and stash a condition ID\r",
									"pm.globals.set(\"condId\", conditions[0].condId);\r",
									"\r",
									"// Specify the expiration date (yyyy-mm-ddThh:mm:ss.sssZ)\r",
									"const xprtnDtTm = \"2024-09-20T12:00:00.000Z\";\r",
									"const messageBody = { \"xprtnDtTm\": xprtnDtTm }\r",
									"// pm.globals.set(\"xprtnDtTm\", undefined);\r",
									"// pm.globals.set(\"xprtnDtTm\", utils.getTimestampNow());\r",
									"// pm.globals.set(\"xprtnDtTm\", \"2024-09-20T12:00:00.000Z\");\r",
									"\r",
									"pm.globals.set(\"messageBody\", JSON.stringify(messageBody));"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{messageBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/entity?id={{dbtrNttyId}}&schmenm={{dbtrNttyIdSchmeNm}}&condid={{condId}}",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"admin",
								"event-flow-control",
								"entity"
							],
							"query": [
								{
									"key": "id",
									"value": "{{dbtrNttyId}}"
								},
								{
									"key": "schmenm",
									"value": "{{dbtrNttyIdSchmeNm}}"
								},
								{
									"key": "condid",
									"value": "{{condId}}"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Create New Entity Condition - No existing entity",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"responseJSON = pm.response.json();\r",
							"let conditionResult = responseJSON.condition;\r",
							"let requestMessage = responseJSON.message;\r",
							"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
							"\r",
							"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
							"targetRequestMessage = \"New condition was saved successfully.\"\r",
							"\r",
							"pm.test(\"Status code is 200\", function () {\r",
							"    pm.response.to.have.status(200);\r",
							"});\r",
							"\r",
							"pm.test(\"Result message matches target result message\", function () {\r",
							"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.evtTp matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.evtTp).to.be.eql(targetConditionResult.evtTp);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.condTp).to.be.eql(targetConditionResult.condTp);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.prsptv matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.prsptv).to.be.eql(targetConditionResult.prsptv);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.ntty.id matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.forceCret matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.forceCret).to.be.eql(targetConditionResult.forceCret);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.usr).to.be.eql(targetConditionResult.usr);\r",
							"});\r",
							"\r",
							"const qryGraphString = `LET vertices = (FOR v,e,p IN 1..2 ANY 'entities/${targetConditionResult.ntty.id + targetConditionResult.ntty.schmeNm.prtry}' governed_as_debtor_by, governed_as_debtor_account_by, governed_as_creditor_by, governed_as_creditor_account_by RETURN distinct v) LET edges = (FOR v,e,p IN 1..2 ANY 'entities/${targetConditionResult.ntty.id + targetConditionResult.ntty.schmeNm.prtry}' governed_as_debtor_by, governed_as_debtor_account_by, governed_as_creditor_by, governed_as_creditor_account_by RETURN distinct e) RETURN {v: vertices, e: edges}`\r",
							"\r",
							"const graphPostRequest = {\r",
							"    url: `${_pm.environment.get('arangoUrl')}/_db/${_pm.environment.get('db_historygraph')}/_api/cursor`,\r",
							"    method: 'POST',\r",
							"    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
							"    body: {\r",
							"        mode: 'raw',\r",
							"        raw: JSON.stringify({\r",
							"            query: qryGraphString\r",
							"        })\r",
							"    }\r",
							"};\r",
							"\r",
							"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
							"    console.log(error ? error : response.json());\r",
							"    graphConditionResult = response.json().result[0];\r",
							"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
							"\r",
							"    pm.test(\"Only one condition exists in the database\", function () {\r",
							"        pm.expect(graphConditionResult.v.length).to.be.eql(2); // one for the entity, one for the condition\r",
							"    });\r",
							"\r",
							"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
							"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
							"            pm.expect(graphConditionResult.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
							"        });\r",
							"    }\r",
							"\r",
							"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
							"    });\r",
							"\r",
							"    let edgeList = [];\r",
							"    for (i = 0; i < graphConditionResult.e.length; i++) {\r",
							"        edgeList.push(graphConditionResult.e[i]._id.substring(0, graphConditionResult.e[i]._id.search('/')));\r",
							"    };\r",
							"\r",
							"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
							"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
							"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
							"    });\r",
							"\r",
							"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
							"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
							"    });\r",
							"\r",
							"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
							"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
							"    });\r",
							"\r",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
							"\r",
							"// Set up the condition\r",
							"\r",
							"messageBody = utils.getCreateEntityConditionBody(\r",
							"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
							"    /* Condition Type */ null,          // null defaults 'non-overridable-block'\r",
							"    /* Perspetive */ null,              // null defaults 'both''\r",
							"    /* Inception Date */ null,          // null defaults now()\r",
							"    /* Expiration Date */ null,         // null defaults now() + 24 hours\r",
							"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
							"    /* Entity */ null,                  // null defaults new unknown entity\r",
							"    /* Force Create */ null,            // null defaults true\r",
							"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
							");\r",
							"\r",
							"// ## Set up body variables\r",
							"\r",
							"pm.globals.set('messageBody', messageBody);\r",
							"\r",
							"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{{messageBody}}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
					"host": [
						"{{tazamaAdminUrl}}{{path-admin-api-version}}"
					],
					"path": [
						"{{path-entity-condition}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Fetch Account Conditions",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"responseJSON = pm.response.json();\r",
							"let conditionResult = responseJSON.condition;\r",
							"let requestMessage = responseJSON.message;\r",
							"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
							"\r",
							"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
							"targetRequestMessage = \"New condition was saved successfully.\"\r",
							"\r",
							"pm.test(\"Status code is 200\", function () {\r",
							"    pm.response.to.have.status(200);\r",
							"});\r",
							"\r",
							"pm.test(\"Result message matches target result message\", function () {\r",
							"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.evtTp matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.evtTp).to.be.eql(targetConditionResult.evtTp);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.condTp).to.be.eql(targetConditionResult.condTp);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.prsptv matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.prsptv).to.be.eql(targetConditionResult.prsptv);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.ntty.id matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.forceCret matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.forceCret).to.be.eql(targetConditionResult.forceCret);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.usr).to.be.eql(targetConditionResult.usr);\r",
							"});\r",
							"\r",
							"const qryGraphString = `LET vertices = (FOR v,e,p IN 1..2 ANY 'entities/${targetConditionResult.ntty.id + targetConditionResult.ntty.schmeNm.prtry}' governed_as_debtor_by, governed_as_debtor_account_by, governed_as_creditor_by, governed_as_creditor_account_by RETURN distinct v) LET edges = (FOR v,e,p IN 1..2 ANY 'entities/${targetConditionResult.ntty.id + targetConditionResult.ntty.schmeNm.prtry}' governed_as_debtor_by, governed_as_debtor_account_by, governed_as_creditor_by, governed_as_creditor_account_by RETURN distinct e) RETURN {v: vertices, e: edges}`\r",
							"\r",
							"const graphPostRequest = {\r",
							"    url: `${_pm.environment.get('arangoUrl')}/_db/${_pm.environment.get('db_historygraph')}/_api/cursor`,\r",
							"    method: 'POST',\r",
							"    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
							"    body: {\r",
							"        mode: 'raw',\r",
							"        raw: JSON.stringify({\r",
							"            query: qryGraphString\r",
							"        })\r",
							"    }\r",
							"};\r",
							"\r",
							"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
							"    console.log(error ? error : response.json());\r",
							"    graphConditionResult = response.json().result[0];\r",
							"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
							"\r",
							"    pm.test(\"Only one condition exists in the database\", function () {\r",
							"        pm.expect(graphConditionResult.v.length).to.be.eql(2); // one for the entity, one for the condition\r",
							"    });\r",
							"\r",
							"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
							"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
							"            pm.expect(graphConditionResult.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
							"        });\r",
							"    }\r",
							"\r",
							"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
							"    });\r",
							"\r",
							"    let edgeList = [];\r",
							"    for (i = 0; i < graphConditionResult.e.length; i++) {\r",
							"        edgeList.push(graphConditionResult.e[i]._id.substring(0, graphConditionResult.e[i]._id.search('/')));\r",
							"    };\r",
							"\r",
							"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
							"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
							"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
							"    });\r",
							"\r",
							"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
							"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
							"    });\r",
							"\r",
							"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
							"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
							"    });\r",
							"\r",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
							"\r",
							"pm.globals.set(\"pacs008\", undefined);\r",
							"\r",
							"// Set up the transaction\r",
							"utils.createNewTransactionSet();\r",
							"\r",
							"pm.globals.set(\"dbtrNttyId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].Id);\r",
							"pm.globals.set(\"dbtrNttyIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].SchmeNm.Prtry);\r",
							"pm.globals.set(\"dbtrAcctId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].Id);\r",
							"pm.globals.set(\"dbtrAcctIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].SchmeNm.Prtry);\r",
							"pm.globals.set(\"dbtrAgt\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAgt.FinInstnId.ClrSysMmbId.MmbId);\r",
							"pm.globals.set(\"cdtrNttyId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0].Id);\r",
							"pm.globals.set(\"cdtrNttyIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0].SchmeNm.Prtry);\r",
							"pm.globals.set(\"cdtrAcctId\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].Id);\r",
							"pm.globals.set(\"cdtrAcctIdSchmeNm\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].SchmeNm.Prtry);\r",
							"pm.globals.set(\"cdtrAgt\", JSON.parse(pm.globals.get(\"pacs008\")).FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAgt.FinInstnId.ClrSysMmbId.MmbId);\r",
							"\r",
							"pm.globals.set(\"synccache\", \"no\");"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"protocolProfileBehavior": {
				"disableBodyPruning": true
			},
			"request": {
				"method": "GET",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{{messageBody}}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{syncCache}}",
					"host": [
						"{{tazamaAdminUrl}}{{path-admin-api-version}}"
					],
					"path": [
						"admin",
						"event-flow-control",
						"account"
					],
					"query": [
						{
							"key": "id",
							"value": "{{dbtrAcctId}}"
						},
						{
							"key": "schmenm",
							"value": "{{dbtrAcctIdSchmeNm}}"
						},
						{
							"key": "agt",
							"value": "{{dbtrAgt}}"
						},
						{
							"key": "synccache",
							"value": "{{syncCache}}"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "Create New Account Condition - no existing account",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"responseJSON = pm.response.json();\r",
							"let conditionResult = responseJSON.conditions;\r",
							"let requestMessage = responseJSON.message;\r",
							"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
							"\r",
							"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
							"targetRequestMessage = \"New condition was saved successfully.\"\r",
							"\r",
							"pm.test(\"Status code is 200\", function () {\r",
							"    pm.response.to.have.status(200);\r",
							"});\r",
							"\r",
							"pm.test(\"Result message matches target result message\", function () {\r",
							"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.evtTp matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.evtTp).to.be.eql(targetConditionResult.evtTp);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.condTp).to.be.eql(targetConditionResult.condTp);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.prsptv matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.prsptv).to.be.eql(targetConditionResult.prsptv);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.acct.id matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.acct.id).to.be.eql(targetConditionResult.acct.id);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.acct.schmeNm.prtry).to.be.eql(targetConditionResult.acct.schmeNm.prtry);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.forceCret matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.forceCret).to.be.eql(targetConditionResult.forceCret);\r",
							"});\r",
							"\r",
							"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
							"    pm.expect(conditionResult.usr).to.be.eql(targetConditionResult.usr);\r",
							"});\r",
							"\r",
							"const qryGraphString = `LET vertices = (FOR v,e,p IN 1..2 ANY 'accounts/${targetConditionResult.acct.id + targetConditionResult.acct.schmeNm.prtry + targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId}' governed_as_debtor_by, governed_as_debtor_account_by, governed_as_creditor_by, governed_as_creditor_account_by RETURN distinct v) LET edges = (FOR v,e,p IN 1..2 ANY 'accounts/${targetConditionResult.acct.id + targetConditionResult.acct.schmeNm.prtry + targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId}' governed_as_debtor_by, governed_as_debtor_account_by, governed_as_creditor_by, governed_as_creditor_account_by RETURN distinct e) RETURN {v: vertices, e: edges}`\r",
							"\r",
							"const graphPostRequest = {\r",
							"    url: `${_pm.environment.get('arangoUrl')}/_db/${_pm.environment.get('db_historygraph')}/_api/cursor`,\r",
							"    method: 'POST',\r",
							"    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
							"    body: {\r",
							"        mode: 'raw',\r",
							"        raw: JSON.stringify({\r",
							"            query: qryGraphString\r",
							"        })\r",
							"    }\r",
							"};\r",
							"\r",
							"await pm.sendRequest(graphPostRequest, (error, response) => {\r",
							"    console.log(error ? error : response.json());\r",
							"    graphConditionResult = response.json().result[0];\r",
							"    console.log(`Database condition graph: ${JSON.stringify(graphConditionResult)}`);\r",
							"\r",
							"    pm.test(\"Only one condition exists in the database\", function () {\r",
							"        pm.expect(graphConditionResult.v.length).to.be.eql(2); // one for the account, one for the condition\r",
							"    });\r",
							"\r",
							"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
							"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
							"            pm.expect(graphConditionResult.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
							"        });\r",
							"    }\r",
							"\r",
							"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.acct.id matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].acct.id).to.be.eql(targetConditionResult.acct.id);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].acct.schmeNm.prtry).to.be.eql(targetConditionResult.acct.schmeNm.prtry);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
							"        pm.expect(graphConditionResult.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
							"    });\r",
							"\r",
							"    let edgeList = [];\r",
							"    for (i = 0; i < graphConditionResult.e.length; i++) {\r",
							"        edgeList.push(graphConditionResult.e[i]._id.substring(0, graphConditionResult.e[i]._id.search('/')));\r",
							"    };\r",
							"\r",
							"    pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
							"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
							"    });\r",
							"\r",
							"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
							"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
							"    });\r",
							"\r",
							"    pm.test(`Database \"governed_as_debtor_account_by\" edge exists`, function () {\r",
							"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_account_by\"]);\r",
							"    });\r",
							"\r",
							"    pm.test(`Database \"governed_as_creditor_account_by\" edge exists`, function () {\r",
							"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_account_by\"]);\r",
							"    });\r",
							"\r",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
							"\r",
							"// Set up the condition\r",
							"\r",
							"messageBody = utils.getCreateAccountConditionBody(\r",
							"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
							"    /* Condition Type */ null,          // null defaults 'non-overridable-block'\r",
							"    /* Perspetive */ null,              // null defaults 'both''\r",
							"    /* Inception Date */ null,          // null defaults null\r",
							"    /* Expiration Date */ null,         // null defaults null\r",
							"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
							"    /* Account */ null,                 // null defaults new unknown account on dfsp001\r",
							"    /* Force Create */ null,            // null defaults true\r",
							"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
							");\r",
							"\r",
							"// ## Set up body variables\r",
							"\r",
							"pm.globals.set('messageBody', messageBody);\r",
							"\r",
							"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{{messageBody}}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
					"host": [
						"{{tazamaAdminUrl}}{{path-admin-api-version}}"
					],
					"path": [
						"{{path-account-condition}}"
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					"const uuid = require('uuid');\r",
					"const lodash = require('lodash');\r",
					"const debtorAgentId = \"fsp001\";\r",
					"const creditorAgentId = \"fsp002\";\r",
					"const debtorIdType = \"TAZAMA_EID\";\r",
					"const debtorAccountType = \"MSISDN\";\r",
					"const creditorIdType = \"TAZAMA_EID\";\r",
					"const creditorAccountType = \"MSISDN\";\r",
					"\r",
					"prep = {\r",
					"\r",
					"    /**\r",
					"     * Constructs a pain.001.001.11 message for initiating a customer credit transfer.\r",
					"     *\r",
					"     * @param {string} messageIdPain001 - Unique identifier for the message.\r",
					"     * @param {string} timestampPain001 - Timestamp of message creation.\r",
					"     * @param {string} debtorDoB - Date of birth of the debtor.\r",
					"     * @param {string} debtorId - Identifier for the debtor.\r",
					"     * @param {string} debtorAccountId - Account identifier for the debtor.\r",
					"     * @param {string} endToEndId - Unique end-to-end transaction identifier.\r",
					"     * @param {string} transactionPurpose - Purpose of the transaction.\r",
					"     * @param {string} currency - Currency code for the transaction amount.\r",
					"     * @param {number} amount - Transaction amount.\r",
					"     * @param {string} creditorId - Identifier for the creditor.\r",
					"     * @param {string} creditorAccountId - Account identifier for the creditor.\r",
					"     * @param {string} transactionDescription - Description of the transaction.\r",
					"     * @param {string} transactionLat - Latitude coordinate of the transaction location.\r",
					"     * @param {string} transactionLong - Longitude coordinate of the transaction location.\r",
					"     * \r",
					"     * @returns {object} A pain.001.001.11 message object for customer credit transfer initiation.\r",
					"     */\r",
					"\r",
					"    prepPain001Msg: function (messageIdPain001, timestampPain001, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountIdType, endToEndId, transactionPurpose, currency, amount, creditorId, creditorIdType, creditorAccountId, creditorAccountIdType, transactionDescription, transactionLat, transactionLong, dataCache) {\r",
					"        return {\r",
					"            \"TxTp\": \"pain.001.001.11\",\r",
					"            \"CstmrCdtTrfInitn\": {\r",
					"                \"GrpHdr\": {\r",
					"                    \"MsgId\": `${messageIdPain001}`,\r",
					"                    \"CreDtTm\": `${timestampPain001}`,\r",
					"                    \"NbOfTxs\": 1,\r",
					"                    \"InitgPty\": {\r",
					"                        \"Nm\": \"April Blake Grant\",\r",
					"                        \"Id\": {\r",
					"                            \"PrvtId\": {\r",
					"                                \"DtAndPlcOfBirth\": {\r",
					"                                    \"BirthDt\": \"1968-02-01\",\r",
					"                                    \"CityOfBirth\": \"Unknown\",\r",
					"                                    \"CtryOfBirth\": \"ZZ\"\r",
					"                                },\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": \"+27730975224\",\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${debtorAccountIdType}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            }\r",
					"                        },\r",
					"                        \"CtctDtls\": {\r",
					"                            \"MobNb\": \"+27-730975224\"\r",
					"                        }\r",
					"                    }\r",
					"                },\r",
					"                \"PmtInf\": {\r",
					"                    \"PmtInfId\": \"5ab4fc7355de4ef8a75b78b00a681ed2\",\r",
					"                    \"PmtMtd\": \"TRA\",\r",
					"                    \"ReqdAdvcTp\": {\r",
					"                        \"DbtAdvc\": {\r",
					"                            \"Cd\": \"ADWD\",\r",
					"                            \"Prtry\": \"Advice with transaction details\"\r",
					"                        }\r",
					"                    },\r",
					"                    \"ReqdExctnDt\": {\r",
					"                        \"Dt\": \"2023-06-02\",\r",
					"                        \"DtTm\": \"2023-06-02T07:50:57.000Z\"\r",
					"                    },\r",
					"                    \"Dbtr\": {\r",
					"                        \"Nm\": \"April Blake Grant\",\r",
					"                        \"Id\": {\r",
					"                            \"PrvtId\": {\r",
					"                                \"DtAndPlcOfBirth\": {\r",
					"                                    \"BirthDt\": `${debtorDoB}`,\r",
					"                                    \"CityOfBirth\": \"Unknown\",\r",
					"                                    \"CtryOfBirth\": \"ZZ\"\r",
					"                                },\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": `${debtorId}`,\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${debtorIdType}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            }\r",
					"                        },\r",
					"                        \"CtctDtls\": {\r",
					"                            \"MobNb\": \"+27-730975224\"\r",
					"                        }\r",
					"                    },\r",
					"                    \"DbtrAcct\": {\r",
					"                        \"Id\": {\r",
					"                            \"Othr\": [{\r",
					"                                \"Id\": `${debtorAccountId}`,\r",
					"                                \"SchmeNm\": {\r",
					"                                    \"Prtry\": `${debtorAccountIdType}`\r",
					"                                }\r",
					"                            }]\r",
					"                        },\r",
					"                        \"Nm\": \"April Grant\"\r",
					"                    },\r",
					"                    \"DbtrAgt\": {\r",
					"                        \"FinInstnId\": {\r",
					"                            \"ClrSysMmbId\": {\r",
					"                                \"MmbId\": `${debtorAgentId}`\r",
					"                            }\r",
					"                        }\r",
					"                    },\r",
					"                    \"CdtTrfTxInf\": {\r",
					"                        \"PmtId\": {\r",
					"                            \"EndToEndId\": `${endToEndId}`\r",
					"                        },\r",
					"                        \"PmtTpInf\": {\r",
					"                            \"CtgyPurp\": {\r",
					"                                \"Prtry\": `${transactionPurpose}`\r",
					"                            }\r",
					"                        },\r",
					"                        \"Amt\": {\r",
					"                            \"InstdAmt\": {\r",
					"                                \"Amt\": {\r",
					"                                    \"Amt\": amount,\r",
					"                                    \"Ccy\": `${currency}`\r",
					"                                }\r",
					"                            },\r",
					"                            \"EqvtAmt\": {\r",
					"                                \"Amt\": {\r",
					"                                    \"Amt\": amount,\r",
					"                                    \"Ccy\": `${currency}`\r",
					"                                },\r",
					"                                \"CcyOfTrf\": `${currency}`\r",
					"                            }\r",
					"                        },\r",
					"                        \"ChrgBr\": \"DEBT\",\r",
					"                        \"CdtrAgt\": {\r",
					"                            \"FinInstnId\": {\r",
					"                                \"ClrSysMmbId\": {\r",
					"                                    \"MmbId\": `${creditorAgentId}`\r",
					"                                }\r",
					"                            }\r",
					"                        },\r",
					"                        \"Cdtr\": {\r",
					"                            \"Nm\": \"Felicia Easton Quill\",\r",
					"                            \"Id\": {\r",
					"                                \"PrvtId\": {\r",
					"                                    \"DtAndPlcOfBirth\": {\r",
					"                                        \"BirthDt\": \"1935-05-08\",\r",
					"                                        \"CityOfBirth\": \"Unknown\",\r",
					"                                        \"CtryOfBirth\": \"ZZ\"\r",
					"                                    },\r",
					"                                    \"Othr\": [{\r",
					"                                        \"Id\": `${creditorId}`,\r",
					"                                        \"SchmeNm\": {\r",
					"                                            \"Prtry\": `${creditorIdType}`\r",
					"                                        }\r",
					"                                    }]\r",
					"                                }\r",
					"                            },\r",
					"                            \"CtctDtls\": {\r",
					"                                \"MobNb\": \"+27-707650428\"\r",
					"                            }\r",
					"                        },\r",
					"                        \"CdtrAcct\": {\r",
					"                            \"Id\": {\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": `${creditorAccountId}`,\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${creditorAccountIdType}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            },\r",
					"                            \"Nm\": \"Felicia Quill\"\r",
					"                        },\r",
					"                        \"Purp\": {\r",
					"                            \"Cd\": \"MP2P\"\r",
					"                        },\r",
					"                        \"RgltryRptg\": {\r",
					"                            \"Dtls\": {\r",
					"                                \"Tp\": \"BALANCE OF PAYMENTS\",\r",
					"                                \"Cd\": \"100\"\r",
					"                            }\r",
					"                        },\r",
					"                        \"RmtInf\": {\r",
					"                            \"Ustrd\": `${transactionDescription}`\r",
					"                        },\r",
					"                        \"SplmtryData\": {\r",
					"                            \"Envlp\": {\r",
					"                                \"Doc\": {\r",
					"                                    \"Dbtr\": {\r",
					"                                        \"FrstNm\": \"April\",\r",
					"                                        \"MddlNm\": \"Blake\",\r",
					"                                        \"LastNm\": \"Grant\",\r",
					"                                        \"MrchntClssfctnCd\": \"BLANK\"\r",
					"                                    },\r",
					"                                    \"Cdtr\": {\r",
					"                                        \"FrstNm\": \"Felicia\",\r",
					"                                        \"MddlNm\": \"Easton\",\r",
					"                                        \"LastNm\": \"Quill\",\r",
					"                                        \"MrchntClssfctnCd\": \"BLANK\"\r",
					"                                    },\r",
					"                                    \"DbtrFinSvcsPrvdrFees\": {\r",
					"                                        \"Ccy\": `${currency}`,\r",
					"                                        \"Amt\": 0.00\r",
					"                                    },\r",
					"                                    \"Xprtn\": \"2021-11-30T10:38:56.000Z\"\r",
					"                                }\r",
					"                            }\r",
					"                        }\r",
					"                    }\r",
					"                },\r",
					"                \"SplmtryData\": {\r",
					"                    \"Envlp\": {\r",
					"                        \"Doc\": {\r",
					"                            \"InitgPty\": {\r",
					"                                \"InitrTp\": \"CONSUMER\",\r",
					"                                \"Glctn\": {\r",
					"                                    \"Lat\": `${transactionLat}`,\r",
					"                                    \"Long\": `${transactionLong}`\r",
					"                                }\r",
					"                            }\r",
					"                        }\r",
					"                    }\r",
					"                }\r",
					"            },\r",
					"            \"DataCache\": dataCache[0]\r",
					"        }\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Constructs a pain.013.001.09 message for initiating a creditor payment activation request.\r",
					"     *\r",
					"     * @param {string} messageIdPain013 - Unique identifier for the message.\r",
					"     * @param {string} timestampPain013 - Timestamp of message creation.\r",
					"     * @param {string} debtorDoB - Date of birth of the debtor.\r",
					"     * @param {string} debtorId - Identifier for the debtor.\r",
					"     * @param {string} debtorAccountId - Account identifier for the debtor.\r",
					"     * @param {string} endToEndId - Unique end-to-end transaction identifier.\r",
					"     * @param {string} currency - Currency code for the transaction amount.\r",
					"     * @param {number} amount - Transaction amount.\r",
					"     * @param {string} creditorId - Identifier for the creditor.\r",
					"     * @param {string} creditorAccountId - Account identifier for the creditor.\r",
					"     * @param {string} transactionLat - Latitude coordinate of the transaction location.\r",
					"     * @param {string} transactionLong - Longitude coordinate of the transaction location.\r",
					"     * \r",
					"     * @returns {object} A pain.013.001.09 message object for creditor payment activation request.\r",
					"     */\r",
					"\r",
					"    prepPain013Msg: function (messageIdPain013, timestampPain013, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountIdType, endToEndId, currency, amount, creditorId, creditorIdType, creditorAccountId, creditorAccountIdType, transactionLat, transactionLong, dataCache) {\r",
					"        return {\r",
					"            \"TxTp\": \"pain.013.001.09\",\r",
					"            \"CdtrPmtActvtnReq\": {\r",
					"                \"GrpHdr\": {\r",
					"                    \"MsgId\": `${messageIdPain013}`,\r",
					"                    \"CreDtTm\": `${timestampPain013}`,\r",
					"                    \"NbOfTxs\": 1,\r",
					"                    \"InitgPty\": {\r",
					"                        \"Nm\": \"April Blake Grant\",\r",
					"                        \"Id\": {\r",
					"                            \"PrvtId\": {\r",
					"                                \"DtAndPlcOfBirth\": {\r",
					"                                    \"BirthDt\": \"1968-02-01\",\r",
					"                                    \"CityOfBirth\": \"Unknown\",\r",
					"                                    \"CtryOfBirth\": \"ZZ\"\r",
					"                                },\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": \"+27730975224\",\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${debtorAccountIdType}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            }\r",
					"                        },\r",
					"                        \"CtctDtls\": {\r",
					"                            \"MobNb\": \"+27-730975224\"\r",
					"                        }\r",
					"                    }\r",
					"                },\r",
					"                \"PmtInf\": {\r",
					"                    \"PmtInfId\": \"5ab4fc7355de4ef8a75b78b00a681ed2\",\r",
					"                    \"PmtMtd\": \"TRA\",\r",
					"                    \"ReqdAdvcTp\": {\r",
					"                        \"DbtAdvc\": {\r",
					"                            \"Cd\": \"ADWD\",\r",
					"                            \"Prtry\": \"Advice with transaction details\"\r",
					"                        }\r",
					"                    },\r",
					"                    \"ReqdExctnDt\": {\r",
					"                        \"DtTm\": \"2023-06-02T07:51:48.000Z\"\r",
					"                    },\r",
					"                    \"XpryDt\": {\r",
					"                        \"DtTm\": \"2021-11-30T10:38:56.000Z\"\r",
					"                    },\r",
					"                    \"Dbtr\": {\r",
					"                        \"Nm\": \"April Blake Grant\",\r",
					"                        \"Id\": {\r",
					"                            \"PrvtId\": {\r",
					"                                \"DtAndPlcOfBirth\": {\r",
					"                                    \"BirthDt\": `${debtorDoB}`,\r",
					"                                    \"CityOfBirth\": \"Unknown\",\r",
					"                                    \"CtryOfBirth\": \"ZZ\"\r",
					"                                },\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": `${debtorId}`,\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${debtorIdType}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            }\r",
					"                        },\r",
					"                        \"CtctDtls\": {\r",
					"                            \"MobNb\": \"+27-730975224\"\r",
					"                        }\r",
					"                    },\r",
					"                    \"DbtrAcct\": {\r",
					"                        \"Id\": {\r",
					"                            \"Othr\": [{\r",
					"                                \"Id\": `${debtorAccountId}`,\r",
					"                                \"SchmeNm\": {\r",
					"                                    \"Prtry\": `${debtorAccountIdType}`\r",
					"                                }\r",
					"                            }]\r",
					"                        },\r",
					"                        \"Nm\": \"April Grant\"\r",
					"                    },\r",
					"                    \"DbtrAgt\": {\r",
					"                        \"FinInstnId\": {\r",
					"                            \"ClrSysMmbId\": {\r",
					"                                \"MmbId\": `${debtorAgentId}`\r",
					"                            }\r",
					"                        }\r",
					"                    },\r",
					"                    \"CdtTrfTxInf\": {\r",
					"                        \"PmtId\": {\r",
					"                            \"EndToEndId\": `${endToEndId}`\r",
					"                        },\r",
					"                        \"PmtTpInf\": {\r",
					"                            \"CtgyPurp\": {\r",
					"                                \"Prtry\": \"TRANSFER BLANK\"\r",
					"                            }\r",
					"                        },\r",
					"                        \"Amt\": {\r",
					"                            \"InstdAmt\": {\r",
					"                                \"Amt\": {\r",
					"                                    \"Amt\": amount,\r",
					"                                    \"Ccy\": `${currency}`\r",
					"                                }\r",
					"                            },\r",
					"                            \"EqvtAmt\": {\r",
					"                                \"Amt\": {\r",
					"                                    \"Amt\": amount,\r",
					"                                    \"Ccy\": `${currency}`\r",
					"                                },\r",
					"                                \"CcyOfTrf\": `${currency}`\r",
					"                            }\r",
					"                        },\r",
					"                        \"ChrgBr\": \"DEBT\",\r",
					"                        \"CdtrAgt\": {\r",
					"                            \"FinInstnId\": {\r",
					"                                \"ClrSysMmbId\": {\r",
					"                                    \"MmbId\": `${creditorAgentId}`\r",
					"                                }\r",
					"                            }\r",
					"                        },\r",
					"                        \"Cdtr\": {\r",
					"                            \"Nm\": \"Felicia Easton Quill\",\r",
					"                            \"Id\": {\r",
					"                                \"PrvtId\": {\r",
					"                                    \"DtAndPlcOfBirth\": {\r",
					"                                        \"BirthDt\": \"1935-05-08\",\r",
					"                                        \"CityOfBirth\": \"Unknown\",\r",
					"                                        \"CtryOfBirth\": \"ZZ\"\r",
					"                                    },\r",
					"                                    \"Othr\": [{\r",
					"                                        \"Id\": `${creditorId}`,\r",
					"                                        \"SchmeNm\": {\r",
					"                                            \"Prtry\": `${creditorIdType}`\r",
					"                                        }\r",
					"                                    }]\r",
					"                                }\r",
					"                            },\r",
					"                            \"CtctDtls\": {\r",
					"                                \"MobNb\": \"+27-707650428\"\r",
					"                            }\r",
					"                        },\r",
					"                        \"CdtrAcct\": {\r",
					"                            \"Id\": {\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": `${creditorAccountId}`,\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${creditorAccountIdType}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            },\r",
					"                            \"Nm\": \"Felicia Quill\"\r",
					"                        },\r",
					"                        \"Purp\": {\r",
					"                            \"Cd\": \"MP2P\"\r",
					"                        },\r",
					"                        \"RgltryRptg\": {\r",
					"                            \"Dtls\": {\r",
					"                                \"Tp\": \"BALANCE OF PAYMENTS\",\r",
					"                                \"Cd\": \"100\"\r",
					"                            }\r",
					"                        },\r",
					"                        \"SplmtryData\": {\r",
					"                            \"Envlp\": {\r",
					"                                \"Doc\": {\r",
					"                                    \"PyeeRcvAmt\": {\r",
					"                                        \"Amt\": {\r",
					"                                            \"Amt\": 0.00,\r",
					"                                            \"Ccy\": `${currency}`\r",
					"                                        }\r",
					"                                    },\r",
					"                                    \"PyeeFinSvcsPrvdrFee\": {\r",
					"                                        \"Amt\": {\r",
					"                                            \"Amt\": 0.00,\r",
					"                                            \"Ccy\": `${currency}`\r",
					"                                        }\r",
					"                                    },\r",
					"                                    \"PyeeFinSvcsPrvdrComssn\": {\r",
					"                                        \"Amt\": {\r",
					"                                            \"Amt\": 0.00,\r",
					"                                            \"Ccy\": `${currency}`\r",
					"                                        }\r",
					"                                    }\r",
					"                                }\r",
					"                            }\r",
					"                        }\r",
					"                    }\r",
					"                },\r",
					"                \"SplmtryData\": {\r",
					"                    \"Envlp\": {\r",
					"                        \"Doc\": {\r",
					"                            \"InitgPty\": {\r",
					"                                \"Glctn\": {\r",
					"                                    \"Lat\": `${transactionLat}`,\r",
					"                                    \"Long\": `${transactionLong}`\r",
					"                                }\r",
					"                            }\r",
					"                        }\r",
					"                    }\r",
					"                }\r",
					"            },\r",
					"            \"DataCache\": dataCache[0]\r",
					"        }\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Constructs a pacs.008.001.10 message for initiating a financial institution to financial institution customer credit transfer.\r",
					"     *\r",
					"     * @param {string} messageIdPacs008 - Unique identifier for the message.\r",
					"     * @param {string} timestampPacs008 - Timestamp of message creation.\r",
					"     * @param {string} endToEndId - Unique end-to-end transaction identifier.\r",
					"     * @param {string} currency - Currency code for the transaction amount.\r",
					"     * @param {number} amount - Transaction amount.\r",
					"     * @param {string} debtorDoB - Date of birth of the debtor.\r",
					"     * @param {string} debtorId - Identifier for the debtor.\r",
					"     * @param {string} debtorAccountId - Account identifier for the debtor.\r",
					"     * @param {string} creditorId - Identifier for the creditor.\r",
					"     * @param {string} creditorAccountId - Account identifier for the creditor.\r",
					"     * @param {string} transactionPurpose - Purpose of the transaction.\r",
					"     * @param {string} transactionDescription - Description of the transaction.\r",
					"     * @param {string} transactionLat - Latitude coordinate of the transaction location.\r",
					"     * @param {string} transactionLong - Longitude coordinate of the transaction location.\r",
					"     * \r",
					"     * @returns {object} A pacs.008.001.10 message object for financial institution to financial institution customer credit transfer.\r",
					"     */\r",
					"\r",
					"    prepPacs008Msg: function (messageIdPacs008, timestampPacs008, endToEndId, currency, amount, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountIdType, creditorId, creditorIdType, creditorAccountId, creditorAccountIdType, transactionPurpose, transactionDescription, transactionLat, transactionLong, dataCache) {\r",
					"\r",
					"        messageBody = {\r",
					"            \"TxTp\": \"pacs.008.001.10\",\r",
					"            \"FIToFICstmrCdtTrf\": {\r",
					"                \"GrpHdr\": {\r",
					"                    \"MsgId\": `${messageIdPacs008}`,\r",
					"                    \"CreDtTm\": `${timestampPacs008}`,\r",
					"                    \"NbOfTxs\": 1,\r",
					"                    \"SttlmInf\": {\r",
					"                        \"SttlmMtd\": \"CLRG\"\r",
					"                    }\r",
					"                },\r",
					"                \"CdtTrfTxInf\": {\r",
					"                    \"PmtId\": {\r",
					"                        \"InstrId\": \"5ab4fc7355de4ef8a75b78b00a681ed2\",\r",
					"                        \"EndToEndId\": `${endToEndId}`\r",
					"                    },\r",
					"                    \"IntrBkSttlmAmt\": {\r",
					"                        \"Amt\": {\r",
					"                            \"Amt\": amount,\r",
					"                            \"Ccy\": `${currency}`\r",
					"                        }\r",
					"                    },\r",
					"                    \"InstdAmt\": {\r",
					"                        \"Amt\": {\r",
					"                            \"Amt\": amount,\r",
					"                            \"Ccy\": `${currency}`\r",
					"                        }\r",
					"                    },\r",
					"                    \"ChrgBr\": \"DEBT\",\r",
					"                    \"ChrgsInf\": {\r",
					"                        \"Amt\": {\r",
					"                            \"Amt\": 0.00,\r",
					"                            \"Ccy\": `${currency}`\r",
					"                        },\r",
					"                        \"Agt\": {\r",
					"                            \"FinInstnId\": {\r",
					"                                \"ClrSysMmbId\": {\r",
					"                                    \"MmbId\": `${debtorAgentId}`\r",
					"                                }\r",
					"                            }\r",
					"                        }\r",
					"                    },\r",
					"                    \"InitgPty\": {\r",
					"                        \"Nm\": \"April Blake Grant\",\r",
					"                        \"Id\": {\r",
					"                            \"PrvtId\": {\r",
					"                                \"DtAndPlcOfBirth\": {\r",
					"                                    \"BirthDt\": \"1968-02-01\",\r",
					"                                    \"CityOfBirth\": \"Unknown\",\r",
					"                                    \"CtryOfBirth\": \"ZZ\"\r",
					"                                },\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": \"+27730975224\",\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${debtorAccountIdType}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            }\r",
					"                        },\r",
					"                        \"CtctDtls\": {\r",
					"                            \"MobNb\": \"+27-730975224\"\r",
					"                        }\r",
					"                    },\r",
					"                    \"Dbtr\": {\r",
					"                        \"Nm\": \"April Blake Grant\",\r",
					"                        \"Id\": {\r",
					"                            \"PrvtId\": {\r",
					"                                \"DtAndPlcOfBirth\": {\r",
					"                                    \"BirthDt\": `${debtorDoB}`,\r",
					"                                    \"CityOfBirth\": \"Unknown\",\r",
					"                                    \"CtryOfBirth\": \"ZZ\"\r",
					"                                },\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": `${debtorId}`,\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${debtorIdType}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            }\r",
					"                        },\r",
					"                        \"CtctDtls\": {\r",
					"                            \"MobNb\": \"+27-730975224\"\r",
					"                        }\r",
					"                    },\r",
					"                    \"DbtrAcct\": {\r",
					"                        \"Id\": {\r",
					"                            \"Othr\": [{\r",
					"                                \"Id\": `${debtorAccountId}`,\r",
					"                                \"SchmeNm\": {\r",
					"                                    \"Prtry\": `${debtorAccountIdType}`\r",
					"                                }\r",
					"                            }]\r",
					"                        },\r",
					"                        \"Nm\": \"April Grant\"\r",
					"                    },\r",
					"                    \"DbtrAgt\": {\r",
					"                        \"FinInstnId\": {\r",
					"                            \"ClrSysMmbId\": {\r",
					"                                \"MmbId\": `${debtorAgentId}`\r",
					"                            }\r",
					"                        }\r",
					"                    },\r",
					"                    \"CdtrAgt\": {\r",
					"                        \"FinInstnId\": {\r",
					"                            \"ClrSysMmbId\": {\r",
					"                                \"MmbId\": `${creditorAgentId}`\r",
					"                            }\r",
					"                        }\r",
					"                    },\r",
					"                    \"Cdtr\": {\r",
					"                        \"Nm\": \"Felicia Easton Quill\",\r",
					"                        \"Id\": {\r",
					"                            \"PrvtId\": {\r",
					"                                \"DtAndPlcOfBirth\": {\r",
					"                                    \"BirthDt\": \"1935-05-08\",\r",
					"                                    \"CityOfBirth\": \"Unknown\",\r",
					"                                    \"CtryOfBirth\": \"ZZ\"\r",
					"                                },\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": `${creditorId}`,\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${creditorIdType}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            }\r",
					"                        },\r",
					"                        \"CtctDtls\": {\r",
					"                            \"MobNb\": \"+27-707650428\"\r",
					"                        }\r",
					"                    },\r",
					"                    \"CdtrAcct\": {\r",
					"                        \"Id\": {\r",
					"                            \"Othr\": [{\r",
					"                                \"Id\": `${creditorAccountId}`,\r",
					"                                \"SchmeNm\": {\r",
					"                                    \"Prtry\": `${creditorAccountIdType}`\r",
					"                                }\r",
					"                            }]\r",
					"                        },\r",
					"                        \"Nm\": \"Felicia Quill\"\r",
					"                    },\r",
					"                    \"Purp\": {\r",
					"                        \"Cd\": `${transactionPurpose}`\r",
					"                    }\r",
					"                },\r",
					"                \"RgltryRptg\": {\r",
					"                    \"Dtls\": {\r",
					"                        \"Tp\": \"BALANCE OF PAYMENTS\",\r",
					"                        \"Cd\": \"100\"\r",
					"                    }\r",
					"                },\r",
					"                \"RmtInf\": {\r",
					"                    \"Ustrd\": `${transactionDescription}`\r",
					"                },\r",
					"                \"SplmtryData\": {\r",
					"                    \"Envlp\": {\r",
					"                        \"Doc\": {\r",
					"                            \"Xprtn\": \"2021-11-30T10:38:56.000Z\",\r",
					"                            \"InitgPty\": {\r",
					"                                \"Glctn\":\r",
					"                                {\r",
					"                                    \"Lat\": `${transactionLat}`,\r",
					"                                    \"Long\": `${transactionLong}`\r",
					"                                }\r",
					"                            }\r",
					"                        }\r",
					"                    }\r",
					"                }\r",
					"            },\r",
					"            \"DataCache\": dataCache[0]\r",
					"        }\r",
					"\r",
					"        return messageBody;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Constructs a pacs.002.001.12 message for financial institution to financial institution payment status reporting.\r",
					"     *\r",
					"     * @param {string} messageIdPacs002 - Unique identifier for the message.\r",
					"     * @param {string} timestampPacs002 - Timestamp of message creation.\r",
					"     * @param {string} endToEndId - Unique end-to-end transaction identifier.\r",
					"     * @param {string} pacs002Sts - Transaction status.\r",
					"     * \r",
					"     * @returns {object} A pacs.002.001.12 message object for financial institution to financial institution payment status reporting.\r",
					"     */\r",
					"\r",
					"    prepPacs002Msg: function (messageIdPacs002, timestampPacs002, endToEndId, pacs002Sts, dataCache) {\r",
					"        return {\r",
					"            \"TxTp\": \"pacs.002.001.12\",\r",
					"            \"FIToFIPmtSts\": {\r",
					"                \"GrpHdr\": {\r",
					"                    \"MsgId\": `${messageIdPacs002}`,\r",
					"                    \"CreDtTm\": `${timestampPacs002}`\r",
					"                },\r",
					"                \"TxInfAndSts\": {\r",
					"                    \"OrgnlInstrId\": \"5ab4fc7355de4ef8a75b78b00a681ed2\",\r",
					"                    \"OrgnlEndToEndId\": `${endToEndId}`,\r",
					"                    \"TxSts\": `${pacs002Sts}`,\r",
					"                    \"ChrgsInf\": [\r",
					"                        {\r",
					"                            \"Amt\": {\r",
					"                                \"Amt\": 0.00,\r",
					"                                \"Ccy\": \"USD\"\r",
					"                            },\r",
					"                            \"Agt\": {\r",
					"                                \"FinInstnId\": {\r",
					"                                    \"ClrSysMmbId\": {\r",
					"                                        \"MmbId\": `${debtorAgentId}`\r",
					"                                    }\r",
					"                                }\r",
					"                            }\r",
					"                        },\r",
					"                        {\r",
					"                            \"Amt\": {\r",
					"                                \"Amt\": 0.00,\r",
					"                                \"Ccy\": \"USD\"\r",
					"                            },\r",
					"                            \"Agt\": {\r",
					"                                \"FinInstnId\": {\r",
					"                                    \"ClrSysMmbId\": {\r",
					"                                        \"MmbId\": `${debtorAgentId}`\r",
					"                                    }\r",
					"                                }\r",
					"                            }\r",
					"                        },\r",
					"                        {\r",
					"                            \"Amt\": {\r",
					"                                \"Amt\": 0.00,\r",
					"                                \"Ccy\": \"USD\"\r",
					"                            },\r",
					"                            \"Agt\": {\r",
					"                                \"FinInstnId\": {\r",
					"                                    \"ClrSysMmbId\": {\r",
					"                                        \"MmbId\": `${creditorAgentId}`\r",
					"                                    }\r",
					"                                }\r",
					"                            }\r",
					"                        }\r",
					"                    ],\r",
					"                    \"AccptncDtTm\": \"2023-06-02T07:52:31.000Z\",\r",
					"                    \"InstgAgt\": {\r",
					"                        \"FinInstnId\": {\r",
					"                            \"ClrSysMmbId\": {\r",
					"                                \"MmbId\": `${debtorAgentId}`\r",
					"                            }\r",
					"                        }\r",
					"                    },\r",
					"                    \"InstdAgt\": {\r",
					"                        \"FinInstnId\": {\r",
					"                            \"ClrSysMmbId\": {\r",
					"                                \"MmbId\": `${creditorAgentId}`\r",
					"                            }\r",
					"                        }\r",
					"                    }\r",
					"                }\r",
					"            },\r",
					"            \"DataCache\": dataCache[0]\r",
					"        }\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Constructs an array of graph entities for a debtor and a creditor.\r",
					"     *\r",
					"     * @param {string} debtorId - Identifier for the debtor.\r",
					"     * @param {string} creditorId - Identifier for the creditor.\r",
					"     * @param {string} timestamp - Timestamp of entity creation.\r",
					"     * \r",
					"     * @returns {Array} An array of graph entities, each containing an identifier and a creation timestamp.\r",
					"     */\r",
					"\r",
					"    prepGraphEntities: function (debtorId, creditorId, timestamp) {\r",
					"        return [{\r",
					"            \"_key\": `${debtorId}`,\r",
					"            \"Id\": `${debtorId}`,\r",
					"            \"CreDtTm\": `${timestamp}`\r",
					"        }, {\r",
					"            \"_key\": `${creditorId}`,\r",
					"            \"Id\": `${creditorId}`,\r",
					"            \"CreDtTm\": `${timestamp}`\r",
					"        }]\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Constructs an array of graph relationships between account holders and their accounts.\r",
					"     *\r",
					"     * @param {string} entitiesPrefix - Prefix for entity identifiers in the graph.\r",
					"     * @param {string} accountsPrefix - Prefix for account identifiers in the graph.\r",
					"     * @param {string} debtorId - Identifier for the debtor.\r",
					"     * @param {string} debtorAccountId - Account identifier for the debtor.\r",
					"     * @param {string} creditorId - Identifier for the creditor.\r",
					"     * @param {string} creditorAccountId - Account identifier for the creditor.\r",
					"     * @param {string} timestamp - Timestamp of relationship creation.\r",
					"     * \r",
					"     * @returns {Array} An array of graph relationships, each connecting an account holder to their account.\r",
					"     */\r",
					"\r",
					"    prepGraphAccountHolders: function (entitiesPrefix, accountsPrefix, debtorId, debtorAccountId, creditorId, creditorAccountId, timestamp) {\r",
					"        return [{\r",
					"            \"_key\": `${debtorId}` + `${debtorAccountId}`,\r",
					"            \"_from\": `${entitiesPrefix}` + `${debtorId}`,\r",
					"            \"_to\": `${accountsPrefix}` + `${debtorAccountId}`,\r",
					"            \"CreDtTm\": `${timestamp}`\r",
					"        },\r",
					"        {\r",
					"            \"_key\": `${creditorId}` + `${creditorAccountId}`,\r",
					"            \"_from\": `${entitiesPrefix}` + `${creditorId}`,\r",
					"            \"_to\": `${accountsPrefix}` + `${creditorAccountId}`,\r",
					"            \"CreDtTm\": `${timestamp}`\r",
					"        }]\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Constructs an array of graph nodes for debtor and creditor accounts.\r",
					"     *\r",
					"     * @param {string} debtorAccountId - Account identifier for the debtor.\r",
					"     * @param {string} creditorAccountId - Account identifier for the creditor.\r",
					"     * \r",
					"     * @returns {Array} An array of graph nodes, each representing an account with a unique identifier.\r",
					"     */\r",
					"\r",
					"    prepGraphAccounts: function (debtorAccountId, creditorAccountId) {\r",
					"        return [{\r",
					"            \"_key\": debtorAccountId,\r",
					"        }, {\r",
					"            \"_key\": creditorAccountId,\r",
					"        }]\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Constructs an array of graph transactions between debtor and creditor accounts, including various transaction types.\r",
					"     *\r",
					"     * @param {string} accountsPrefix - Prefix for account identifiers in the graph.\r",
					"     * @param {string} debtorAccountId - Account identifier for the debtor.\r",
					"     * @param {string} creditorAccountId - Account identifier for the creditor.\r",
					"     * @param {string} currency - Currency code for the transaction amount.\r",
					"     * @param {number} amount - Transaction amount.\r",
					"     * @param {string} endToEndId - Unique end-to-end transaction identifier.\r",
					"     * @param {string} timestampPacs008 - Timestamp of pacs.008.001.10 message creation.\r",
					"     * @param {string} messageIdPacs008 - Unique identifier for the pacs.008.001.10 message.\r",
					"     * @param {string} timestampPacs002 - Timestamp of pacs.002.001.12 message creation.\r",
					"     * @param {string} messageIdPacs002 - Unique identifier for the pacs.002.001.12 message.\r",
					"     * @param {string} pacs002Sts - Transaction status for pacs.002.001.12 message.\r",
					"     * @param {string} timestampPain001 - Timestamp of pain.001.001.11 message creation.\r",
					"     * @param {string} messageIdPain001 - Unique identifier for the pain.001.001.11 message.\r",
					"     * @param {string} timestampPain013 - Timestamp of pain.013.001.09 message creation.\r",
					"     * @param {string} messageIdPain013 - Unique identifier for the pain.013.001.09 message.\r",
					"     * \r",
					"     * @returns {Array} An array of graph transactions, each representing a transaction between debtor and creditor accounts.\r",
					"     */\r",
					"\r",
					"    prepGraphTransactions: function (accountsPrefix, debtorAccountId, creditorAccountId, currency, amount, endToEndId, timestampPacs008, messageIdPacs008, timestampPacs002, messageIdPacs002, pacs002Sts, timestampPain001, messageIdPain001, timestampPain013, messageIdPain013) {\r",
					"\r",
					"        var transactions = [];\r",
					"\r",
					"        if (typeof timestampPain001 !== \"undefined\") {\r",
					"            transactions.push({\r",
					"                \"_from\": `${accountsPrefix}` + `${debtorAccountId}`,\r",
					"                \"_to\": `${accountsPrefix}` + `${creditorAccountId}`,\r",
					"                \"TxTp\": \"pain.001.001.11\",\r",
					"                \"CreDtTm\": `${timestampPain001}`,\r",
					"                \"Amt\": amount,\r",
					"                \"Ccy\": `${currency}`,\r",
					"                \"PmtInfId\": `${messageIdPain001}`,\r",
					"                \"EndToEndId\": `${endToEndId}`\r",
					"            });\r",
					"            transactions.push({\r",
					"                \"_from\": `${accountsPrefix}` + `${creditorAccountId}`,\r",
					"                \"_to\": `${accountsPrefix}` + `${debtorAccountId}`,\r",
					"                \"TxTp\": \"pain.013.001.09\",\r",
					"                \"CreDtTm\": `${timestampPain013}`,\r",
					"                \"Amt\": amount,\r",
					"                \"Ccy\": `${currency}`,\r",
					"                \"PmtInfId\": `${messageIdPain013}`,\r",
					"                \"EndToEndId\": `${endToEndId}`\r",
					"            });\r",
					"        }\r",
					"\r",
					"        transactions.push({\r",
					"            \"_from\": `${accountsPrefix}` + `${debtorAccountId}`,\r",
					"            \"_to\": `${accountsPrefix}` + `${creditorAccountId}`,\r",
					"            \"TxTp\": \"pacs.008.001.10\",\r",
					"            \"CreDtTm\": `${timestampPacs008}`,\r",
					"            \"Amt\": amount,\r",
					"            \"Ccy\": `${currency}`,\r",
					"            \"PmtInfId\": `${messageIdPacs008}`,\r",
					"            \"EndToEndId\": `${endToEndId}`\r",
					"        });\r",
					"\r",
					"        if (typeof timestampPacs002 !== \"undefined\") {\r",
					"            transactions.push({\r",
					"                \"_from\": `${accountsPrefix}` + `${creditorAccountId}`,\r",
					"                \"_to\": `${accountsPrefix}` + `${debtorAccountId}`,\r",
					"                \"TxTp\": \"pacs.002.001.12\",\r",
					"                \"TxSts\": `${pacs002Sts}`,\r",
					"                \"CreDtTm\": `${timestampPacs002}`,\r",
					"                \"PmtInfId\": `${messageIdPacs002}`,\r",
					"                \"EndToEndId\": `${endToEndId}`\r",
					"            });\r",
					"        }\r",
					"\r",
					"        return transactions\r",
					"    }\r",
					"}\r",
					"\r",
					"config = {\r",
					"\r",
					"    /**\r",
					"    * Asynchronously deletes a specific rule configuration from the database.\r",
					"    *\r",
					"    * @param {string} ruleId - Mandatory. The identifier of the rule whose configuration is to be deleted.\r",
					"    * @param {string} ruleConfigVersion - Mandatory. The version of the rule configuration to be deleted.\r",
					"    */\r",
					"\r",
					"    deleteRuleConfig: async function (ruleId, ruleConfigVersion) {\r",
					"\r",
					"        const queryString = `FOR cfg IN configuration\r",
					"      FILTER cfg.id == '${ruleId}'\r",
					"      AND cfg.cfg == '${ruleConfigVersion}'\r",
					"      REMOVE cfg._key IN configuration`;\r",
					"\r",
					"        const configPostRequest = {\r",
					"            url: `${_pm.environment.get('arangoUrl')}/_db/${_pm.environment.get('db_config_all')}/_api/cursor`,\r",
					"            method: 'POST',\r",
					"            header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"            body: {\r",
					"                mode: 'raw',\r",
					"                raw: JSON.stringify({\r",
					"                    query: queryString\r",
					"                })\r",
					"            }\r",
					"        };\r",
					"\r",
					"        await _pm.sendRequest(configPostRequest, (error, response) => {\r",
					"            console.log(error ? error : response.json());\r",
					"        });\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Asynchronously creates a new rule configuration in the database.\r",
					"     *\r",
					"     * @param {object} ruleConfig - Mandatory. The configuration object for the rule to be created.\r",
					"     */\r",
					"\r",
					"\r",
					"    createRuleConfig: async function (ruleConfig) {\r",
					"\r",
					"        const configPostRequest = {\r",
					"            url: `${_pm.environment.get('arangoUrl')}/_db/${_pm.environment.get('db_config_all')}/_api/document/${_pm.environment.get('db_config_rules')}?overwrite=true`,\r",
					"            method: 'POST',\r",
					"            header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"            body: {\r",
					"                mode: 'raw',\r",
					"                raw: JSON.stringify(ruleConfig)\r",
					"            },\r",
					"        };\r",
					"\r",
					"        await _pm.sendRequest(configPostRequest, (error, response) => {\r",
					"            console.log(error ? error : response.json());\r",
					"        });\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Asynchronously recreates a rule configuration by removing the existing configuration and creating a new one.\r",
					"     *\r",
					"     * @param {string} ruleId - Mandatory. The identifier of the rule whose configuration is to be recreated.\r",
					"     * @param {string} ruleConfigVersion - Mandatory. The version of the rule configuration.\r",
					"     * @param {object} ruleConfig - Mandatory. The new configuration object for the rule.\r",
					"     */\r",
					"\r",
					"    recreateRuleConfig: async function (ruleId, ruleConfigVersion, ruleConfig) {\r",
					"\r",
					"        const queryString = `FOR cfg IN configuration\r",
					"      FILTER cfg.id == '${ruleId}'\r",
					"      AND cfg.cfg == '${ruleConfigVersion}'\r",
					"      REMOVE cfg._key IN configuration`;\r",
					"\r",
					"        const configPostRequest = {\r",
					"            url: `${_pm.environment.get('arangoUrl')}/_db/${_pm.environment.get('db_config_all')}/_api/cursor`,\r",
					"            method: 'POST',\r",
					"            header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"            body: {\r",
					"                mode: 'raw',\r",
					"                raw: JSON.stringify({\r",
					"                    query: queryString\r",
					"                })\r",
					"            }\r",
					"        };\r",
					"\r",
					"        await _pm.sendRequest(configPostRequest, (error, response) => {\r",
					"            console.log(error ? error : response.json());\r",
					"            utils.createRuleConfig(ruleConfig);\r",
					"        });\r",
					"    }\r",
					"}\r",
					"\r",
					"utils = {\r",
					"    // https://community.postman.com/t/how-to-reuse-function-in-2022/39077/4\r",
					"    setPm: function (scriptPm) {\r",
					"        try {\r",
					"            if (!scriptPm) {\r",
					"                throw new Error(\"The pm object is not provided.\");\r",
					"            }\r",
					"            _pm = scriptPm;\r",
					"            console.log(\"pm object successfully set.\");\r",
					"        } catch (error) {\r",
					"            console.error(\"Failed to set pm object:\", error.message);\r",
					"        }\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Converts a time unit to its equivalent in milliseconds.\r",
					"     * \r",
					"     * Example: `weekInMilliseconds = 7 * utils.timeframe('d');`\r",
					"     *\r",
					"     * @param {string} unit - The time unit to convert. Supported units are 'd'/'days', 'h'/'hours', 'm'/'minutes', and 's'/'seconds'.\r",
					"     * @returns {number} The number of milliseconds corresponding to the given time unit.\r",
					"     */\r",
					"\r",
					"    timeframe: function (unit) {\r",
					"        switch (unit) {\r",
					"            case 'd':\r",
					"            case 'days':\r",
					"                milliseconds = 86400000;\r",
					"                break;\r",
					"            case 'h':\r",
					"            case 'hours':\r",
					"                milliseconds = 3600000;\r",
					"                break;\r",
					"            case 'm':\r",
					"            case 'minutes':\r",
					"                milliseconds = 60000;\r",
					"                break;\r",
					"            case 's':\r",
					"            case 'seconds':\r",
					"                milliseconds = 1000;\r",
					"                break;\r",
					"            default: milliseconds = 0;\r",
					"        }\r",
					"        return milliseconds;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Generates a UUID (Universally Unique Identifier) in ISO format by removing hyphens from a standard UUID.\r",
					"     *\r",
					"     * @returns {string} A UUID in ISO format without hyphens.\r",
					"     */\r",
					"\r",
					"    createISOUUID: function () {\r",
					"        return uuid.v4().replace(/-/g, '');\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Logs a structured message containing payment transaction details to the console.\r",
					"     * This function facilitates easy tracking and debugging of transaction data by displaying it in a structured JSON format.\r",
					"     *\r",
					"     * @param {Object} dataCache - An object containing all the necessary transaction data.\r",
					"     *   @param {string} data.dbtrId - Debtor's identifier.\r",
					"     *   @param {string} data.cdtrId - Creditor's identifier.\r",
					"     *   @param {string} data.dbtrAcctId - Debtor's account identifier.\r",
					"     *   @param {string} data.cdtrAcctId - Creditor's account identifier.\r",
					"     *   @param {string} data.creDtTm - Creation date and time of the transaction, formatted as ISO 8601.\r",
					"     *   @param {number} data.amt - Transaction amount.\r",
					"     *   @param {string} data.curr - Currency of the transaction amount.\r",
					"     *   @param {string} data.endToEndId - End-to-end identifier that uniquely references the transaction.\r",
					"     *\r",
					"     * @example\r",
					"     * logDataCache({\r",
					"     *   dbtrId: '123',\r",
					"     *   cdtrId: '456',\r",
					"     *   dbtrAcctId: '78910',\r",
					"     *   cdtrAcctId: '111213',\r",
					"     *   creDtTm: '2020-12-31T23:59:59',\r",
					"     *   amt: 100.00,\r",
					"     *   curr: 'USD',\r",
					"     *   endToEndId: 'E2E123456789'\r",
					"     * });\r",
					"     */\r",
					"\r",
					"    logDataCache: function (dataCache) {\r",
					"        console.log(JSON.stringify({ DataCache: dataCache }, null, 4));\r",
					"    },\r",
					"\r",
					"    getTimestampNow: function () {\r",
					"        return new Date(new Date(Date.now())).toISOString();\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Creates multiple new accounts for a given entity and updates the graph database with the new accounts and their relationships to the entity.\r",
					"     *\r",
					"     * @param {string} entityId - Mandatory. Identifier for the entity to which the accounts will be associated.\r",
					"     * @param {number|null|undefined} [numberOfAccounts=0] - The number of new accounts to create. Defaults to 0.\r",
					"     */\r",
					"\r",
					"    createMoreAccounts: function (entityId, numberOfAccounts) {\r",
					"\r",
					"        const arangoUrl = _pm.environment.get('arangoUrl');\r",
					"        const db_historygraph = _pm.environment.get('db_historygraph');\r",
					"        const db_coll_graph_accounts = _pm.environment.get('db_coll_graph_accounts');\r",
					"        const db_coll_graph_account_holders = _pm.environment.get('db_coll_graph_account_holders');\r",
					"        const accountsPrefix = 'accounts/';\r",
					"        const entitiesPrefix = 'entities/';\r",
					"\r",
					"        // Variables for test data parameterisation\r",
					"\r",
					"        // Essential defaults\r",
					"        numberOfAccounts = numberOfAccounts ? numberOfAccounts : 0;\r",
					"\r",
					"        let timestamp = new Date(new Date(Date.now())).toISOString();\r",
					"\r",
					"        const accountIds = [];\r",
					"        for (let step = 0; step < numberOfAccounts; step++) {\r",
					"            accountIds.push('acct_' + uuid.v4().replace(/-/g, ''));\r",
					"        }\r",
					"\r",
					"        const accounts = [];\r",
					"        for (let step = 0; step < numberOfAccounts; step++) {\r",
					"            accounts.push({ \"_key\": accountIds[step] })\r",
					"        }\r",
					"\r",
					"        const account_holders = [];\r",
					"        for (let step = 0; step < numberOfAccounts; step++) {\r",
					"            account_holders.push({\r",
					"                \"_key\": `${entityId}+${accountIds[step]}`,\r",
					"                \"_from\": `${entitiesPrefix}` + `${entityId}`,\r",
					"                \"_to\": `${accountsPrefix}` + `${accountIds[step]}`,\r",
					"                \"CreDtTm\": timestamp\r",
					"            });\r",
					"        }\r",
					"\r",
					"        postRequests = [{\r",
					"            url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_accounts}`,\r",
					"            method: 'POST',\r",
					"            header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"            body: {\r",
					"                mode: 'raw',\r",
					"                raw: JSON.stringify(accounts)\r",
					"            }\r",
					"        }, {\r",
					"            url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_account_holders}`,\r",
					"            method: 'POST',\r",
					"            header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"            body: {\r",
					"                mode: 'raw',\r",
					"                raw: JSON.stringify(account_holders)\r",
					"            }\r",
					"        }];\r",
					"\r",
					"        postRequests.forEach((postRequest) => {\r",
					"            _pm.sendRequest(postRequest, (error, response) => {\r",
					"                console.log(error ? error : response.json());\r",
					"            });\r",
					"        });\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Creates a single new account for a given entity and updates the graph database with the new account and its relationship to the entity.\r",
					"     *\r",
					"     * @param {string} entityId - Mandatory. Identifier for the entity to which the account will be associated.\r",
					"     * @param {string} accountId - Mandatory. Identifier for the new account.\r",
					"     * @param {string|null|undefined} [timestamp] - Timestamp for the creation of the account. Defaults to the current timestamp.\r",
					"     */\r",
					"\r",
					"    createSingleAccount: function (entityId, accountId, timestamp) {\r",
					"\r",
					"        const arangoUrl = _pm.environment.get('arangoUrl');\r",
					"        const db_historygraph = _pm.environment.get('db_historygraph');\r",
					"        const db_coll_graph_accounts = _pm.environment.get('db_coll_graph_accounts');\r",
					"        const db_coll_graph_account_holders = _pm.environment.get('db_coll_graph_account_holders');\r",
					"        const accountsPrefix = 'accounts/';\r",
					"        const entitiesPrefix = 'entities/';\r",
					"\r",
					"        // Variables for test data parameterisation\r",
					"\r",
					"        // Essential defaults\r",
					"        const numberOfAccounts = 1;\r",
					"\r",
					"        timestamp = timestamp ? timestamp : new Date(new Date(Date.now())).toISOString();\r",
					"\r",
					"        const accountIds = [];\r",
					"        for (let step = 0; step < numberOfAccounts; step++) {\r",
					"            accountIds.push(accountId);\r",
					"        }\r",
					"\r",
					"        const accounts = [];\r",
					"        for (let step = 0; step < numberOfAccounts; step++) {\r",
					"            accounts.push({ \"_key\": accountIds[step] })\r",
					"        }\r",
					"\r",
					"        const account_holders = [];\r",
					"        for (let step = 0; step < numberOfAccounts; step++) {\r",
					"            account_holders.push({\r",
					"                \"_from\": `${entitiesPrefix}` + `${entityId}`,\r",
					"                \"_to\": `${accountsPrefix}` + `${accountIds[step]}`,\r",
					"                \"CreDtTm\": `${timestamp}`\r",
					"            });\r",
					"        }\r",
					"\r",
					"        postRequests = [{\r",
					"            url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_accounts}`,\r",
					"            method: 'POST',\r",
					"            header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"            body: {\r",
					"                mode: 'raw',\r",
					"                raw: JSON.stringify(accounts)\r",
					"            }\r",
					"        }, {\r",
					"            url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_account_holders}`,\r",
					"            method: 'POST',\r",
					"            header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"            body: {\r",
					"                mode: 'raw',\r",
					"                raw: JSON.stringify(account_holders)\r",
					"            }\r",
					"        }];\r",
					"\r",
					"        postRequests.forEach((postRequest) => {\r",
					"            _pm.sendRequest(postRequest, (error, response) => {\r",
					"                console.log(error ? error : response.json());\r",
					"            });\r",
					"        });\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Creates a new entity in the graph database with the given entity identifier.\r",
					"     *\r",
					"     * @param {string} entityId - Mandatory. Identifier for the new entity.\r",
					"     */\r",
					"\r",
					"    createEntity: function (entityId) {\r",
					"        const arangoUrl = _pm.environment.get('arangoUrl');\r",
					"        const db_historygraph = _pm.environment.get('db_historygraph');\r",
					"        const db_coll_graph_entities = _pm.environment.get('db_coll_graph_entities');\r",
					"        const entitiesPrefix = 'entities/';\r",
					"\r",
					"        // Essential defaults\r",
					"        const timestamp = new Date(new Date(Date.now())).toISOString();\r",
					"\r",
					"        const entities = [{\r",
					"            \"_key\": entityId,\r",
					"            \"Id\": entityId,\r",
					"            \"CreDtTm\": timestamp\r",
					"        }];\r",
					"\r",
					"        postRequests = [{\r",
					"            url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_entities}`,\r",
					"            method: 'POST',\r",
					"            header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"            body: {\r",
					"                mode: 'raw',\r",
					"                raw: JSON.stringify(entities)\r",
					"            }\r",
					"        }];\r",
					"\r",
					"        postRequests.forEach((postRequest) => {\r",
					"            _pm.sendRequest(postRequest, (error, response) => {\r",
					"                console.log(error ? error : response.json());\r",
					"            });\r",
					"        });\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Creates a new set of transactions for testing purposes, including all necessary data and database operations.\r",
					"     * The transaction set will include pain.001/013 messages if the environment variable activePain001 = true.\r",
					"     * The transaction set will contain a pacs.008 and a pacs.002 message.\r",
					"     * The messages in the set will be linked through the same EndToEndId.\r",
					"     * The function stashes created data in global variables can be retrieved with the `pm.globals.get()` method.\r",
					"     *\r",
					"     * @param {number|null|undefined} [timestampEpoch=0] - Epoch timestamp for adjusting transaction timestamps. Defaults to 0.\r",
					"     * @param {string|null|undefined} [currency='XTS'] - Currency code for the transaction amount. Defaults to 'XTS'.\r",
					"     * @param {number|null|undefined} [amount] - Transaction amount. Defaults to a random value between 10 and 1000.\r",
					"     * @param {string|null|undefined} [transactionDescription='Generic payment description'] - Description of the transaction. Defaults to 'Generic payment description'.\r",
					"     * @param {string|null|undefined} [pacs002Sts='ACCC'] - Transaction status for pacs.002.001.12 message. Defaults to 'ACCC' (a successful transaction).\r",
					"     * @param {number|null|undefined} [debtorAge=25] - Age of the debtor. Defaults to 25.\r",
					"     * @param {string|null|undefined} [transactionPurpose] - Purpose of the transaction. Defaults to 'TRANSFER' if pain.001/013 ingestion is enabled, otherwise 'MP2P'.\r",
					"     * @param {number|null|undefined} [transactionLat=-3.1609] - Latitude coordinate of the transaction location. Defaults to -3.1609.\r",
					"     * @param {number|null|undefined} [transactionLong=38.3588] - Longitude coordinate of the transaction location. Defaults to 38.3588.\r",
					"     */\r",
					"\r",
					"    createNewTransactionSet: function (timestampEpoch, currency, amount, transactionDescription, pacs002Sts, debtorAge, transactionPurpose, transactionLat, transactionLong) {\r",
					"\r",
					"        const activePain001 = JSON.parse(_pm.environment.get('activePain001'));\r",
					"        activePain001 ? console.log(\"pain.001/013 ingestion is enabled\") : console.log(\"pain.001/013 ingestion is disabled\");\r",
					"        const arangoUrl = _pm.environment.get('arangoUrl');\r",
					"        const db_messagehistory = _pm.environment.get('db_messagehistory');\r",
					"        const db_historygraph = _pm.environment.get('db_historygraph');\r",
					"        const db_coll_graph_transactions = _pm.environment.get('db_coll_graph_transactions');\r",
					"        const db_coll_graph_entities = _pm.environment.get('db_coll_graph_entities');\r",
					"        const db_coll_graph_accounts = _pm.environment.get('db_coll_graph_accounts');\r",
					"        const db_coll_graph_account_holders = _pm.environment.get('db_coll_graph_account_holders');\r",
					"\r",
					"        var db_coll_msg_transactionHistoryPain001;\r",
					"        var db_coll_msg_transactionHistoryPain013;\r",
					"        if (activePain001) {\r",
					"            db_coll_msg_transactionHistoryPain001 = _pm.environment.get('db_coll_msg_transactionHistoryPain001');\r",
					"            db_coll_msg_transactionHistoryPain013 = _pm.environment.get('db_coll_msg_transactionHistoryPain013');\r",
					"        }\r",
					"        const db_coll_msg_transactionHistoryPacs008 = _pm.environment.get('db_coll_msg_transactionHistoryPacs008');\r",
					"        const db_coll_msg_transactionHistoryPacs002 = _pm.environment.get('db_coll_msg_transactionHistoryPacs002');\r",
					"        const accountsPrefix = 'accounts/';\r",
					"        const entitiesPrefix = 'entities/';\r",
					"\r",
					"        // Variables for test data parameterisation\r",
					"\r",
					"        // Essential defaults\r",
					"        timestampEpoch = timestampEpoch ? timestampEpoch : 0;\r",
					"        currency = currency ? currency : 'XTS';\r",
					"        amount = amount ? amount : Math.round((Math.random() * (1000 - 10) + 10) * 100) / 100;\r",
					"        transactionDescription = transactionDescription ? transactionDescription : 'Generic payment description';\r",
					"        pacs002Sts = pacs002Sts ? pacs002Sts : 'ACCC';\r",
					"        debtorAge = debtorAge ? debtorAge : 25;\r",
					"        if (activePain001) {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'TRANSFER' // or 'WITHDRAWAL', or 'PAYMENT'\r",
					"        } else {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'MP2P' // or 'MP2B', or 'CASH'\r",
					"        }\r",
					"        transactionLat = transactionLat ? transactionLat : -3.1609\r",
					"        transactionLong = transactionLong ? transactionLong : 38.3588\r",
					"\r",
					"        // Defaults\r",
					"        const timestampInterval = 300000; // 300,000 milliseconds = 5 minutes\r",
					"        let debtorId = 'dbtr_' + uuid.v4().replace(/-/g, '');\r",
					"        let debtorAccountId = 'dbtrAcct_' + uuid.v4().replace(/-/g, '');\r",
					"        let creditorId = 'cdtr_' + uuid.v4().replace(/-/g, '');\r",
					"        let creditorAccountId = 'cdtrAcct_' + uuid.v4().replace(/-/g, '');\r",
					"        let debtorDoB = new Date(new Date().setDate(new Date().getDate() - (debtorAge * 366))).toISOString().substring(0, 10);\r",
					"        let timestampPacs008 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 1)).toISOString();\r",
					"        let timestampPacs002 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 0)).toISOString();\r",
					"        console.log(\"pacs.002 payload timestamp: \" + timestampPacs002);\r",
					"        let endToEndId = uuid.v4().replace(/-/g, '');\r",
					"        let messageIdPacs008 = uuid.v4().replace(/-/g, '');\r",
					"        let messageIdPacs002 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"        var timestampPain001;\r",
					"        var timestampPain013;\r",
					"        var messageIdPain001;\r",
					"        var messageIdPain013;\r",
					"        var pain001;\r",
					"        var pain013;\r",
					"        var baseCreDtTm;\r",
					"        if (activePain001) {\r",
					"            timestampPain001 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 3)).toISOString();\r",
					"            timestampPain013 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 2)).toISOString();\r",
					"            baseCreDtTm = timestampPain001;\r",
					"        } else {\r",
					"            baseCreDtTm = timestampPacs008;\r",
					"        }\r",
					"\r",
					"        var debtorKey = debtorId + debtorIdType;\r",
					"        var debtorAccountKey = debtorAccountId + debtorAccountType + debtorAgentId;\r",
					"        var creditorKey = creditorId + creditorIdType;\r",
					"        var creditorAccountKey = creditorAccountId + debtorAccountType + creditorAgentId;\r",
					"\r",
					"        const dataCache = [{\r",
					"            \"dbtrId\": `${debtorKey}`,\r",
					"            \"cdtrId\": `${creditorKey}`,\r",
					"            \"dbtrAcctId\": `${debtorAccountKey}`,\r",
					"            \"cdtrAcctId\": `${creditorAccountKey}`,\r",
					"            \"creDtTm\": `${baseCreDtTm}`,\r",
					"            \"amt\": {\r",
					"                \"amt\": amount,\r",
					"                \"ccy\": `${currency}`\r",
					"            }\r",
					"        }];\r",
					"\r",
					"        if (activePain001) {\r",
					"            messageIdPain001 = uuid.v4().replace(/-/g, '');\r",
					"            messageIdPain013 = uuid.v4().replace(/-/g, '');\r",
					"            pain001 = [prep.prepPain001Msg(messageIdPain001, timestampPain001, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, transactionPurpose, currency, amount, creditorId, creditorIdType, creditorAccountId, creditAccountType, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"\r",
					"            pain013 = [prep.prepPain013Msg(messageIdPain013, timestampPain013, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, currency, amount, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionLat, transactionLong, dataCache)];\r",
					"        }\r",
					"\r",
					"        const pacs008 = [prep.prepPacs008Msg(messageIdPacs008, timestampPacs008, endToEndId, currency, amount, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionPurpose, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"\r",
					"        const pacs002 = [prep.prepPacs002Msg(messageIdPacs002, timestampPacs002, endToEndId, pacs002Sts, dataCache)];\r",
					"\r",
					"        const pacs002TriggerPayload = pacs002;\r",
					"\r",
					"        const accounts = prep.prepGraphAccounts(debtorAccountKey, creditorAccountKey);\r",
					"\r",
					"        var postRequests = [];\r",
					"        var account_holders = [];\r",
					"        var entities = [];\r",
					"        var transactions = [];\r",
					"\r",
					"        if (activePain001) {\r",
					"            entities = prep.prepGraphEntities(debtorKey, creditorKey, timestampPain001);\r",
					"            account_holders = prep.prepGraphAccountHolders(entitiesPrefix, accountsPrefix, debtorKey, debtorAccountKey, creditorKey, creditorAccountKey, timestampPain001);\r",
					"            transactions = prep.prepGraphTransactions(accountsPrefix, debtorAccountKey, creditorAccountKey, currency, amount, endToEndId, timestampPacs008, messageIdPacs008, timestampPacs002, messageIdPacs002, pacs002Sts, timestampPain001, messageIdPain001, timestampPain013, messageIdPain013);\r",
					"\r",
					"            postRequests = [{\r",
					"                url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPain001}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(pain001)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPain013}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(pain013)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPacs008}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(pacs008)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPacs002}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(pacs002)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_accounts}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(accounts)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_entities}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(entities)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_transactions}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(transactions)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_account_holders}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(account_holders)\r",
					"                }\r",
					"            }];\r",
					"        } else {\r",
					"            entities = prep.prepGraphEntities(debtorKey, creditorKey, timestampPacs008);\r",
					"            account_holders = prep.prepGraphAccountHolders(entitiesPrefix, accountsPrefix, debtorKey, debtorAccountKey, creditorKey, creditorAccountKey, timestampPacs008);\r",
					"            transactions = prep.prepGraphTransactions(accountsPrefix, debtorAccountKey, creditorAccountKey, currency, amount, endToEndId, timestampPacs008, messageIdPacs008, timestampPacs002, messageIdPacs002, pacs002Sts);\r",
					"\r",
					"            postRequests = [{\r",
					"                url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPacs008}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(pacs008)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPacs002}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(pacs002)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_accounts}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(accounts)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_entities}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(entities)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_transactions}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(transactions)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_account_holders}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(account_holders)\r",
					"                }\r",
					"            }];\r",
					"            console.log(postRequests);\r",
					"        }\r",
					"\r",
					"        postRequests.forEach((postRequest) => {\r",
					"            _pm.sendRequest(postRequest, (error, response) => {\r",
					"                console.log(error ? error : response.json());\r",
					"            });\r",
					"        });\r",
					"\r",
					"        let deleteDataCache = lodash.unset(pacs002[0], \"DataCache\");\r",
					"\r",
					"        console.log('pacs.002 trigger payload: ' + JSON.stringify(pacs002TriggerPayload[0]));\r",
					"\r",
					"        _pm.globals.set(\"pacs008\", JSON.stringify(pacs008[0]));\r",
					"        _pm.globals.set(\"pacs002\", JSON.stringify(pacs002TriggerPayload[0]));\r",
					"        _pm.globals.set(\"dataCache\", JSON.stringify(dataCache[0]));\r",
					"        _pm.globals.set('debtorId', debtorId);\r",
					"        _pm.globals.set('debtorAccountId', debtorAccountId);\r",
					"        _pm.globals.set('debtorDoB', debtorDoB);\r",
					"        _pm.globals.set('creditorId', creditorId);\r",
					"        _pm.globals.set('creditorAccountId', creditorAccountId);\r",
					"        _pm.globals.set('timestampPacs008', timestampPacs008);\r",
					"        _pm.globals.set('timestampPacs002', timestampPacs002);\r",
					"        _pm.globals.set('endToEndId', endToEndId);\r",
					"        _pm.globals.set('pacs002Sts', pacs002Sts);\r",
					"        _pm.globals.set('currency', currency);\r",
					"        _pm.globals.set('amount', amount);\r",
					"        _pm.globals.set('transactionDescription', transactionDescription);\r",
					"        _pm.globals.set('transactionPurpose', transactionPurpose);\r",
					"        _pm.globals.set('transactionLat', transactionLat);\r",
					"        _pm.globals.set('transactionLong', transactionLong);\r",
					"        _pm.globals.set('messageIdPacs008', messageIdPacs008);\r",
					"        _pm.globals.set('messageIdPacs002', messageIdPacs002);\r",
					"        _pm.globals.set('baseTimestamp', timestampPacs008);\r",
					"        _pm.globals.set('debtorKey', debtorKey);\r",
					"        _pm.globals.set('debtorAccountKey', debtorAccountKey);\r",
					"        _pm.globals.set('creditorKey', creditorKey);\r",
					"        _pm.globals.set('creditorAccountKey', creditorAccountKey);\r",
					"        if (activePain001) {\r",
					"            _pm.globals.set('timestampPain001', timestampPain001);\r",
					"            _pm.globals.set('timestampPain013', timestampPain013);\r",
					"            _pm.globals.set('messageIdPain001', messageIdPain001);\r",
					"            _pm.globals.set('messageIdPain013', messageIdPain013);\r",
					"            _pm.globals.set('baseTimestamp', timestampPain001);\r",
					"        }\r",
					"\r",
					"        this.logDataCache(dataCache[0]);\r",
					"\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Creates a new set of transactions for testing purposes, excluding pacs.002.001.12 messages, and includes all necessary data and database operations.\r",
					"     * The transaction set will include pain.001/013 messages if the environment variable activePain001 = true.\r",
					"     * The transaction set will contain a pacs.008 message.\r",
					"     * The messages in the set will be linked through the same EndToEndId.\r",
					"     * The function stashes created data in global variables can be retrieved with the `pm.globals.get()` method.\r",
					"     *\r",
					"     * @param {number|null|undefined} [timestampEpoch=0] - Epoch timestamp for adjusting transaction timestamps. Defaults to 0.\r",
					"     * @param {string|null|undefined} [currency='XTS'] - Currency code for the transaction amount. Defaults to 'XTS'.\r",
					"     * @param {number|null|undefined} [amount] - Transaction amount. Defaults to a random value between 10 and 1000.\r",
					"     * @param {string|null|undefined} [transactionDescription='Generic payment description'] - Description of the transaction. Defaults to 'Generic payment description'.\r",
					"     * @param {string|null|undefined} [pacs002Sts='ACCC'] - Transaction status for pacs.002.001.12 message. Defaults to 'ACCC'.\r",
					"     * @param {number|null|undefined} [debtorAge=25] - Age of the debtor. Defaults to 25.\r",
					"     * @param {string|null|undefined} [transactionPurpose] - Purpose of the transaction. Defaults to 'TRANSFER' if pain.001/013 ingestion is enabled, otherwise 'MP2P'.\r",
					"     * @param {number|null|undefined} [transactionLat=-3.1609] - Latitude coordinate of the transaction location. Defaults to -3.1609.\r",
					"     * @param {number|null|undefined} [transactionLong=38.3588] - Longitude coordinate of the transaction location. Defaults to 38.3588.\r",
					"     */\r",
					"\r",
					"    createNewTransactionSetWithoutPacs002: function (timestampEpoch, currency, amount, transactionDescription, pacs002Sts, debtorAge, transactionPurpose, transactionLat, transactionLong) {\r",
					"\r",
					"        const activePain001 = JSON.parse(_pm.environment.get('activePain001'));\r",
					"        activePain001 ? console.log(\"pain.001/013 ingestion is enabled\") : console.log(\"pain.001/013 ingestion is disabled\");\r",
					"        const arangoUrl = _pm.environment.get('arangoUrl');\r",
					"        const db_messagehistory = _pm.environment.get('db_messagehistory');\r",
					"        const db_historygraph = _pm.environment.get('db_historygraph');\r",
					"        const db_coll_graph_transactions = _pm.environment.get('db_coll_graph_transactions');\r",
					"        const db_coll_graph_entities = _pm.environment.get('db_coll_graph_entities');\r",
					"        const db_coll_graph_accounts = _pm.environment.get('db_coll_graph_accounts');\r",
					"        const db_coll_graph_account_holders = _pm.environment.get('db_coll_graph_account_holders');\r",
					"        const db_coll_msg_transactionHistoryPacs008 = _pm.environment.get('db_coll_msg_transactionHistoryPacs008');\r",
					"        const db_coll_msg_transactionHistoryPacs002 = _pm.environment.get('db_coll_msg_transactionHistoryPacs002');\r",
					"        const accountsPrefix = 'accounts/';\r",
					"        const entitiesPrefix = 'entities/';\r",
					"\r",
					"        // Variables for test data parameterisation\r",
					"\r",
					"        // Essential defaults\r",
					"        timestampEpoch = timestampEpoch ? timestampEpoch : 0;\r",
					"        currency = currency ? currency : 'XTS';\r",
					"        amount = amount ? amount : Math.round((Math.random() * (1000 - 10) + 10) * 100) / 100;\r",
					"        transactionDescription = transactionDescription ? transactionDescription : 'Generic payment description';\r",
					"        pacs002Sts = pacs002Sts ? pacs002Sts : 'ACCC';\r",
					"        debtorAge = debtorAge ? debtorAge : 25;\r",
					"        if (activePain001) {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'TRANSFER' // or 'WITHDRAWAL', or 'PAYMENT'\r",
					"        } else {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'MP2P' // or 'MP2B', or 'CASH'\r",
					"        }\r",
					"        transactionLat = transactionLat ? transactionLat : -3.1609\r",
					"        transactionLong = transactionLong ? transactionLong : 38.3588\r",
					"\r",
					"        // Defaults\r",
					"        const timestampInterval = 300000; // 300,000 milliseconds = 5 minutes\r",
					"        let debtorId = 'dbtr_' + uuid.v4().replace(/-/g, '');\r",
					"        let debtorAccountId = 'dbtrAcct_' + uuid.v4().replace(/-/g, '');\r",
					"        let creditorId = 'cdtr_' + uuid.v4().replace(/-/g, '');\r",
					"        let creditorAccountId = 'cdtrAcct_' + uuid.v4().replace(/-/g, '');\r",
					"        let debtorDoB = new Date(new Date().setDate(new Date().getDate() - (debtorAge * 366))).toISOString().substring(0, 10);\r",
					"        let timestampPacs008 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 1)).toISOString();\r",
					"        let timestampPacs002 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 0)).toISOString();\r",
					"        console.log(\"pacs.002 payload timestamp: \" + timestampPacs002);\r",
					"        let endToEndId = uuid.v4().replace(/-/g, '');\r",
					"        let messageIdPacs008 = uuid.v4().replace(/-/g, '');\r",
					"        let messageIdPacs002 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"        var timestampPain001;\r",
					"        var timestampPain013;\r",
					"        var messageIdPain001;\r",
					"        var messageIdPain013;\r",
					"\r",
					"        var db_coll_msg_transactionHistoryPain001;\r",
					"        var db_coll_msg_transactionHistoryPain013;\r",
					"\r",
					"        var pain001;\r",
					"        var pain013;\r",
					"        var baseCreDtTm;\r",
					"        if (activePain001) {\r",
					"            timestampPain001 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 3)).toISOString();\r",
					"            timestampPain013 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 2)).toISOString();\r",
					"            baseCreDtTm = timestampPain001;\r",
					"        } else {\r",
					"            baseCreDtTm = timestampPacs008;\r",
					"        }\r",
					"\r",
					"        var debtorKey = debtorId + debtorIdType;\r",
					"        var debtorAccountKey = debtorAccountId + debtorAccountType + debtorAgentId;\r",
					"        var creditorKey = creditorId + creditorIdType;\r",
					"        var creditorAccountKey = creditorAccountId + debtorAccountType + creditorAgentId;\r",
					"\r",
					"        const dataCache = [{\r",
					"            \"dbtrId\": `${debtorKey}`,\r",
					"            \"cdtrId\": `${creditorKey}`,\r",
					"            \"dbtrAcctId\": `${debtorAccountKey}`,\r",
					"            \"cdtrAcctId\": `${creditorAccountKey}`,\r",
					"            \"creDtTm\": `${baseCreDtTm}`,\r",
					"            \"amt\": {\r",
					"                \"amt\": amount,\r",
					"                \"ccy\": `${currency}`\r",
					"            }\r",
					"        }];\r",
					"\r",
					"        if (activePain001) {\r",
					"            db_coll_msg_transactionHistoryPain001 = _pm.environment.get('db_coll_msg_transactionHistoryPain001');\r",
					"            db_coll_msg_transactionHistoryPain013 = _pm.environment.get('db_coll_msg_transactionHistoryPain013');\r",
					"            messageIdPain001 = uuid.v4().replace(/-/g, '');\r",
					"            messageIdPain013 = uuid.v4().replace(/-/g, '');\r",
					"            pain001 = [prep.prepPain001Msg(messageIdPain001, timestampPain001, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, transactionPurpose, currency, amount, creditorId, creditorIdType, creditorAccountId, creditAccountType, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"\r",
					"            pain013 = [prep.prepPain013Msg(messageIdPain013, timestampPain013, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, currency, amount, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionLat, transactionLong, dataCache)];\r",
					"        }\r",
					"\r",
					"        const pacs008 = [prep.prepPacs008Msg(messageIdPacs008, timestampPacs008, endToEndId, currency, amount, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionPurpose, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"\r",
					"        const pacs002 = [prep.prepPacs002Msg(messageIdPacs002, timestampPacs002, endToEndId, pacs002Sts, dataCache)];\r",
					"\r",
					"        const pacs002TriggerPayload = pacs002;\r",
					"\r",
					"        const accounts = prep.prepGraphAccounts(debtorAccountKey, creditorAccountKey);\r",
					"\r",
					"        var postRequests = [];\r",
					"        var account_holders = [];\r",
					"        var entities = [];\r",
					"        var transactions = [];\r",
					"\r",
					"        if (activePain001) {\r",
					"            entities = prep.prepGraphEntities(debtorKey, creditorKey, timestampPain001);\r",
					"            account_holders = prep.prepGraphAccountHolders(entitiesPrefix, accountsPrefix, debtorKey, debtorAccountKey, creditorKey, creditorAccountKey, timestampPain001);\r",
					"            transactions = prep.prepGraphTransactions(accountsPrefix, debtorAccountKey, creditorAccountKey, currency, amount, endToEndId, timestampPacs008, messageIdPacs008, undefined, undefined, undefined, timestampPain001, messageIdPain001, timestampPain013, messageIdPain013);\r",
					"\r",
					"            postRequests = [{\r",
					"                url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPain001}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(pain001)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPain013}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(pain013)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPacs008}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(pacs008)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_accounts}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(accounts)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_entities}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(entities)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_transactions}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(transactions)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_account_holders}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(account_holders)\r",
					"                }\r",
					"            }];\r",
					"        } else {\r",
					"            entities = prep.prepGraphEntities(debtorKey, creditorKey, timestampPacs008);\r",
					"            account_holders = prep.prepGraphAccountHolders(entitiesPrefix, accountsPrefix, debtorKey, debtorAccountKey, creditorKey, creditorAccountKey, timestampPacs008);\r",
					"            transactions = prep.prepGraphTransactions(accountsPrefix, debtorAccountKey, creditorAccountKey, currency, amount, endToEndId, timestampPacs008, messageIdPacs008);\r",
					"\r",
					"            postRequests = [{\r",
					"                url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPacs008}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(pacs008)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_accounts}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(accounts)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_entities}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(entities)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_transactions}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(transactions)\r",
					"                }\r",
					"            }, {\r",
					"                url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_account_holders}`,\r",
					"                method: 'POST',\r",
					"                header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                body: {\r",
					"                    mode: 'raw',\r",
					"                    raw: JSON.stringify(account_holders)\r",
					"                }\r",
					"            }];\r",
					"        }\r",
					"\r",
					"        postRequests.forEach((postRequest) => {\r",
					"            _pm.sendRequest(postRequest, (error, response) => {\r",
					"                console.log(error ? error : response.json());\r",
					"            });\r",
					"        });\r",
					"\r",
					"        console.log('pacs.002 trigger payload for Data Preparation: ' + JSON.stringify(pacs002TriggerPayload[0]));\r",
					"\r",
					"        _pm.globals.set(\"pacs002DataPrep\", JSON.stringify(pacs002TriggerPayload[0]));\r",
					"        _pm.globals.set(\"dataCache\", JSON.stringify(dataCache[0]));\r",
					"        _pm.globals.set('debtorId', debtorId);\r",
					"        _pm.globals.set('debtorAccountId', debtorAccountId);\r",
					"        _pm.globals.set('debtorDoB', debtorDoB);\r",
					"        _pm.globals.set('creditorId', creditorId);\r",
					"        _pm.globals.set('creditorAccountId', creditorAccountId);\r",
					"        _pm.globals.set('timestampPacs008', timestampPacs008);\r",
					"        _pm.globals.set('timestampPacs002', timestampPacs002);\r",
					"        _pm.globals.set('endToEndId', endToEndId);\r",
					"        _pm.globals.set('pacs002Sts', pacs002Sts);\r",
					"        _pm.globals.set('currency', currency);\r",
					"        _pm.globals.set('amount', amount);\r",
					"        _pm.globals.set('transactionDescription', transactionDescription);\r",
					"        _pm.globals.set('transactionPurpose', transactionPurpose);\r",
					"        _pm.globals.set('transactionLat', transactionLat);\r",
					"        _pm.globals.set('transactionLong', transactionLong);\r",
					"        _pm.globals.set('messageIdPacs008', messageIdPacs008);\r",
					"        _pm.globals.set('messageIdPacs002', messageIdPacs002);\r",
					"        _pm.globals.set('baseTimestamp', timestampPacs008);\r",
					"        _pm.globals.set('debtorKey', debtorKey);\r",
					"        _pm.globals.set('debtorAccountKey', debtorAccountKey);\r",
					"        _pm.globals.set('creditorKey', creditorKey);\r",
					"        _pm.globals.set('creditorAccountKey', creditorAccountKey);\r",
					"        if (activePain001) {\r",
					"            _pm.globals.set('timestampPain001', timestampPain001);\r",
					"            _pm.globals.set('timestampPain013', timestampPain013);\r",
					"            _pm.globals.set('messageIdPain001', messageIdPain001);\r",
					"            _pm.globals.set('messageIdPain013', messageIdPain013);\r",
					"            _pm.globals.set('baseTimestamp', timestampPain001);\r",
					"        }\r",
					"\r",
					"        this.logDataCache(dataCache[0]);\r",
					"\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Creates multiple sets of transactions for testing purposes, each with its own unique identifiers and timestamps, and includes all necessary data and database operations.\r",
					"     * The transaction sets will include pain.001/013 messages if the environment variable activePain001 = true.\r",
					"     * The transaction set will contain a pacs.008 and a pacs.002 message.\r",
					"     * The messages in the set will be linked through the same EndToEndId.\r",
					"     * The function stashes created data in global variables can be retrieved with the `pm.globals.get()` method.\r",
					"     *\r",
					"     * @param {number|null|undefined} [numberOfSets=1] - The number of transaction sets to create. Defaults to 1.\r",
					"     * @param {string|null|undefined} [debtorIdRef=null] - Reference identifier for the debtor. If provided, this ID will be used for all transaction sets. Defaults to null, which means a new ID will be generated for each set.\r",
					"     * @param {string|null|undefined} [debtorAccountIdRef=null] - Reference account identifier for the debtor. If provided, this ID will be used for all transaction sets. Defaults to null, which means a new ID will be generated for each set.\r",
					"     * @param {string|null|undefined} [creditorIdRef=null] - Reference identifier for the creditor. If provided, this ID will be used for all transaction sets. Defaults to null, which means a new ID will be generated for each set.\r",
					"     * @param {string|null|undefined} [creditorAccountIdRef=null] - Reference account identifier for the creditor. If provided, this ID will be used for all transaction sets. Defaults to null, which means a new ID will be generated for each set.\r",
					"     * @param {number|null|undefined} [timestampEpoch=0] - Epoch timestamp for adjusting transaction timestamps. Defaults to 0.\r",
					"     * @param {number|null|undefined} [timestampIterationLeap] - The leap in milliseconds between each transaction set's timestamp. Defaults to the total epoch divided by the number of sets or 0 if only one set is created.\r",
					"     * @param {string|null|undefined} [currency='XTS'] - Currency code for the transaction amount. Defaults to 'XTS'.\r",
					"     * @param {number|null|undefined} [amountRef=null] - Reference amount for the transaction. If provided, this amount will be used for all transaction sets. Defaults to null, which means a random amount will be generated for each set.\r",
					"     * @param {string|null|undefined} [transactionDescriptionRef=null] - Reference description for the transaction. If provided, this description will be used for all transaction sets. Defaults to null, which means a random description will be generated for each set.\r",
					"     * @param {string|null|undefined} [pacs002Sts='ACCC'] - Transaction status for pacs.002.001.12 message. Defaults to 'ACCC' (a successul transaction).\r",
					"     * @param {number|null|undefined} [debtorAge=25] - Age of the debtor. Defaults to 25.\r",
					"     * @param {string|null|undefined} [transactionPurpose] - Purpose of the transaction. Defaults to 'TRANSFER' if pain.001/013 ingestion is enabled, otherwise 'MP2P'.\r",
					"     * @param {number|null|undefined} [transactionLat=-3.1609] - Latitude coordinate of the transaction location. Defaults to -3.1609.\r",
					"     * @param {number|null|undefined} [transactionLong=38.3588] - Longitude coordinate of the transaction location. Defaults to 38.3588.\r",
					"     */\r",
					"\r",
					"    createMoreTransactionSets: function (numberOfSets, debtorIdRef, debtorAccountIdRef, creditorIdRef, creditorAccountIdRef, timestampEpoch, timestampIterationLeap, currency, amountRef, transactionDescriptionRef, pacs002Sts, debtorAge, transactionPurpose, transactionLat, transactionLong) {\r",
					"\r",
					"        const activePain001 = JSON.parse(_pm.environment.get('activePain001'));\r",
					"        activePain001 ? console.log(\"pain.001/013 ingestion is enabled\") : console.log(\"pain.001/013 ingestion is disabled\");\r",
					"        const arangoUrl = _pm.environment.get('arangoUrl');\r",
					"        const db_messagehistory = _pm.environment.get('db_messagehistory');\r",
					"        const db_historygraph = _pm.environment.get('db_historygraph');\r",
					"        const db_coll_graph_transactions = _pm.environment.get('db_coll_graph_transactions');\r",
					"\r",
					"        var db_coll_msg_transactionHistoryPain001;\r",
					"        var db_coll_msg_transactionHistoryPain013;\r",
					"        if (activePain001) {\r",
					"            db_coll_msg_transactionHistoryPain001 = _pm.environment.get('db_coll_msg_transactionHistoryPain001');\r",
					"            db_coll_msg_transactionHistoryPain013 = _pm.environment.get('db_coll_msg_transactionHistoryPain013');\r",
					"        }\r",
					"        const db_coll_msg_transactionHistoryPacs008 = _pm.environment.get('db_coll_msg_transactionHistoryPacs008');\r",
					"        const db_coll_msg_transactionHistoryPacs002 = _pm.environment.get('db_coll_msg_transactionHistoryPacs002');\r",
					"        const accountsPrefix = 'accounts/';\r",
					"\r",
					"        // Variables for test data parameterisation\r",
					"\r",
					"        // Essential defaults\r",
					"        numberOfSets = numberOfSets ? numberOfSets : 1;\r",
					"        timestampEpoch = timestampEpoch ? timestampEpoch : 0;\r",
					"        currency = currency ? currency : 'XTS';\r",
					"        if (numberOfSets == 1) {\r",
					"            timestampIterationLeap = 0\r",
					"        } else {\r",
					"            timestampIterationLeap = timestampIterationLeap ? timestampIterationLeap : Math.trunc(timestampEpoch / numberOfSets)\r",
					"        }\r",
					"        pacs002Sts = pacs002Sts ? pacs002Sts : 'ACCC';\r",
					"        debtorAge = debtorAge ? debtorAge : 25;\r",
					"        if (activePain001) {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'TRANSFER' // or 'WITHDRAWAL', or 'PAYMENT'\r",
					"        } else {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'MP2P' // or 'MP2B', or 'CASH'\r",
					"        }\r",
					"        transactionLat = transactionLat ? transactionLat : -3.1609\r",
					"        transactionLong = transactionLong ? transactionLong : 38.3588\r",
					"\r",
					"        // Defaults\r",
					"        const timestampInterval = 300000; // 300,000 milliseconds = 5 minutes\r",
					"        let debtorDoB = new Date(new Date().setDate(new Date().getDate() - (debtorAge * 366))).toISOString().substring(0, 10);\r",
					"        timestampEpochStart = timestampEpoch;\r",
					"\r",
					"        for (let step = 0; step < numberOfSets; step++) {\r",
					"            // Match incoming parameter or randomise\r",
					"            let debtorId = debtorIdRef || 'dbtr_' + uuid.v4().replace(/-/g, '') + debtorIdType;\r",
					"            let debtorAccountId = debtorAccountIdRef || 'dbtrAcct_' + uuid.v4().replace(/-/g, '') + debtorAccountType + debtorAgentId;\r",
					"            let creditorId = creditorIdRef || 'cdtr_' + uuid.v4().replace(/-/g, '') + creditorIdType;\r",
					"            let creditorAccountId = creditorAccountIdRef || 'cdtrAcct_' + uuid.v4().replace(/-/g, '') + debtorAccountType + creditorAgentId;\r",
					"\r",
					"            var debtorKey = debtorId;\r",
					"            var debtorAccountKey = debtorAccountId;\r",
					"            var creditorKey = creditorId;\r",
					"            var creditorAccountKey = creditorAccountId;\r",
					"\r",
					"            let amount = amountRef || Math.round((Math.random() * (1000 - 10) + 10) * 100) / 100;\r",
					"            let transactionDescription = transactionDescriptionRef || uuid.v4().replace(/-/g, '');\r",
					"            let timestampPacs008 = new Date(new Date(Date.now() - timestampEpochStart + (timestampIterationLeap * step) - timestampInterval * 1)).toISOString();\r",
					"            let timestampPacs002 = new Date(new Date(Date.now() - timestampEpochStart + (timestampIterationLeap * step) - timestampInterval * 0)).toISOString();\r",
					"\r",
					"            if (!debtorIdRef) {\r",
					"                utils.createEntity(debtorId);\r",
					"            }\r",
					"            if (!creditorIdRef) {\r",
					"                utils.createEntity(creditorId);\r",
					"            }\r",
					"            if (!debtorAccountIdRef) {\r",
					"                utils.createSingleAccount(debtorKey, debtorAccountKey, timestampPacs008);\r",
					"            }\r",
					"            if (!creditorAccountIdRef) {\r",
					"                utils.createSingleAccount(creditorKey, creditorAccountKey, timestampPacs008);\r",
					"            }\r",
					"\r",
					"            let endToEndId = uuid.v4().replace(/-/g, '');\r",
					"            let messageIdPacs008 = uuid.v4().replace(/-/g, '');\r",
					"            let messageIdPacs002 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"            var timestampPain001;\r",
					"            var timestampPain013;\r",
					"            var messageIdPain001;\r",
					"            var messageIdPain013;\r",
					"\r",
					"            var baseCreDtTm;\r",
					"            if (activePain001) {\r",
					"                timestampPain001 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 3)).toISOString();\r",
					"                timestampPain013 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 2)).toISOString();\r",
					"                baseCreDtTm = timestampPain001;\r",
					"            } else {\r",
					"                baseCreDtTm = timestampPacs008;\r",
					"            }\r",
					"\r",
					"            const dataCache = [{\r",
					"                \"dbtrId\": `${debtorKey}`,\r",
					"                \"cdtrId\": `${creditorKey}`,\r",
					"                \"dbtrAcctId\": `${debtorAccountKey}`,\r",
					"                \"cdtrAcctId\": `${creditorAccountKey}`,\r",
					"                \"creDtTm\": `${baseCreDtTm}`,\r",
					"                \"amt\": {\r",
					"                    \"amt\": amount,\r",
					"                    \"ccy\": `${currency}`\r",
					"                }\r",
					"            }];\r",
					"\r",
					"            var pain001;\r",
					"            var pain013;\r",
					"\r",
					"            if (activePain001) {\r",
					"                messageIdPain001 = uuid.v4().replace(/-/g, '');\r",
					"                messageIdPain013 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"                pain001 = [prep.prepPain001Msg(messageIdPain001, timestampPain001, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, transactionPurpose, currency, amount, creditorId, creditorIdType, creditorAccountId, creditAccountType, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"\r",
					"                pain013 = [prep.prepPain013Msg(messageIdPain013, timestampPain013, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, currency, amount, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionLat, transactionLong, dataCache)];\r",
					"            }\r",
					"\r",
					"            const pacs008 = [prep.prepPacs008Msg(messageIdPacs008, timestampPacs008, endToEndId, currency, amount, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionPurpose, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"\r",
					"            const pacs002 = [prep.prepPacs002Msg(messageIdPacs002, timestampPacs002, endToEndId, pacs002Sts, dataCache)];\r",
					"\r",
					"            var transactions = [];\r",
					"            var postRequests = [];\r",
					"\r",
					"            if (activePain001) {\r",
					"                transactions = prep.prepGraphTransactions(accountsPrefix, debtorAccountKey, creditorAccountKey, currency, amount, endToEndId, timestampPacs008, messageIdPacs008, timestampPacs002, messageIdPacs002, pacs002Sts, timestampPain001, messageIdPain001, timestampPain013, messageIdPain013);\r",
					"\r",
					"                postRequests = [{\r",
					"                    url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPain001}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(pain001)\r",
					"                    }\r",
					"                }, {\r",
					"                    url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPain013}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(pain013)\r",
					"                    }\r",
					"                }, {\r",
					"                    url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPacs008}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(pacs008)\r",
					"                    }\r",
					"                }, {\r",
					"                    url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPacs002}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(pacs002)\r",
					"                    }\r",
					"                }, {\r",
					"                    url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_transactions}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(transactions)\r",
					"                    }\r",
					"                }];\r",
					"            } else {\r",
					"                let transactions = [{\r",
					"                    \"_from\": `${accountsPrefix}` + `${debtorAccountId}`,\r",
					"                    \"_to\": `${accountsPrefix}` + `${creditorAccountId}`,\r",
					"                    \"TxTp\": \"pacs.008.001.10\",\r",
					"                    \"CreDtTm\": `${timestampPacs008}`,\r",
					"                    \"Amt\": amount,\r",
					"                    \"Ccy\": currency,\r",
					"                    \"PmtInfId\": `${messageIdPacs008}`,\r",
					"                    \"EndToEndId\": `${endToEndId}`\r",
					"                },\r",
					"                {\r",
					"                    \"_from\": `${accountsPrefix}` + `${creditorAccountId}`,\r",
					"                    \"_to\": `${accountsPrefix}` + `${debtorAccountId}`,\r",
					"                    \"TxTp\": \"pacs.002.001.12\",\r",
					"                    \"TxSts\": `${pacs002Sts}`,\r",
					"                    \"CreDtTm\": `${timestampPacs002}`,\r",
					"                    \"PmtInfId\": `${messageIdPacs002}`,\r",
					"                    \"EndToEndId\": `${endToEndId}`\r",
					"                }]\r",
					"\r",
					"                postRequests = [{\r",
					"                    url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPacs008}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(pacs008)\r",
					"                    }\r",
					"                }, {\r",
					"                    url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPacs002}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(pacs002)\r",
					"                    }\r",
					"                }, {\r",
					"                    url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_transactions}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(transactions)\r",
					"                    }\r",
					"                }];\r",
					"            }\r",
					"\r",
					"            postRequests.forEach((postRequest) => {\r",
					"                _pm.sendRequest(postRequest, (error, response) => {\r",
					"                    console.log(error ? error : response.json());\r",
					"                });\r",
					"            });\r",
					"\r",
					"            if (activePain001) {\r",
					"                console.log(`Created transaction set ${step + 1}/${numberOfSets} from ${debtorAccountId} to ${creditorAccountId} from pain.001:${timestampPain001} to pacs.002:${timestampPacs002} with EndToEndId ${endToEndId}`);\r",
					"            } else {\r",
					"                console.log(`Created transaction set ${step + 1}/${numberOfSets} from ${debtorAccountId} to ${creditorAccountId} from pacs.008:${timestampPacs008} to pacs.002${timestampPacs002} with EndToEndId ${endToEndId}`);\r",
					"            }\r",
					"\r",
					"        }\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Creates multiple sets of transactions for testing purposes, each with its own unique identifiers and timestamps, and includes all necessary data and database operations.\r",
					"     * This function allows more rapid transactions compared to the `createNewTransactionSet` or `createMoreTransactionSets` functions that separates transactions with a .\r",
					"     * The transaction sets will include pain.001/013 messages if the environment variable activePain001 = true.\r",
					"     * The transaction set will contain a pacs.008 and a pacs.002 message.\r",
					"     * The messages in the set will be linked through the same EndToEndId.\r",
					"     * The function stashes created data in global variables can be retrieved with the `pm.globals.get()` method.\r",
					"     *\r",
					"     * @param {number|null|undefined} [numberOfSets=1] - The number of transaction sets to create. Defaults to 1.\r",
					"     * @param {string|null|undefined} [debtorIdRef=null] - Reference identifier for the debtor. If provided, this ID will be used for all transaction sets. Defaults to null, which means a new ID will be generated for each set.\r",
					"     * @param {string|null|undefined} [debtorAccountIdRef=null] - Reference account identifier for the debtor. If provided, this ID will be used for all transaction sets. Defaults to null, which means a new ID will be generated for each set.\r",
					"     * @param {string|null|undefined} [creditorIdRef=null] - Reference identifier for the creditor. If provided, this ID will be used for all transaction sets. Defaults to null, which means a new ID will be generated for each set.\r",
					"     * @param {string|null|undefined} [creditorAccountIdRef=null] - Reference account identifier for the creditor. If provided, this ID will be used for all transaction sets. Defaults to null, which means a new ID will be generated for each set.\r",
					"     * @param {number|null|undefined} [timestampEpoch=0] - Epoch timestamp for adjusting transaction timestamps. Defaults to 0.\r",
					"     * @param {number|null|undefined} [timestampIterationLeap] - The leap in milliseconds between each transaction set's timestamp. Defaults to the total epoch divided by the number of sets or 0 if only one set is created.\r",
					"     * @param {number|null|undefined} [timestampInterval=300000] - Interval in milliseconds between different types of messages within a transaction set. Defaults to 300,000 milliseconds (5 minutes).\r",
					"     * @param {string|null|undefined} [currency='XTS'] - Currency code for the transaction amount. Defaults to 'XTS'.\r",
					"     * @param {number|null|undefined} [amountRef=null] - Reference amount for the transaction. If provided, this amount will be used for all transaction sets. Defaults to null, which means a random amount will be generated for each set.\r",
					"     * @param {string|null|undefined} [transactionDescriptionRef=null] - Reference description for the transaction. If provided, this description will be used for all transaction sets. Defaults to null, which means a random description will be generated for each set.\r",
					"     * @param {string|null|undefined} [pacs002Sts='ACCC'] - Transaction status for pacs.002.001.12 message. Defaults to 'ACCC' (a successful transaction).\r",
					"     * @param {number|null|undefined} [debtorAge=25] - Age of the debtor. Defaults to 25.\r",
					"     * @param {string|null|undefined} [transactionPurpose] - Purpose of the transaction. Defaults to 'TRANSFER' if pain.001/013 ingestion is enabled, otherwise 'MP2P'.\r",
					"     * @param {number|null|undefined} [transactionLat=-3.1609] - Latitude coordinate of the transaction location. Defaults to -3.1609.\r",
					"     * @param {number|null|undefined} [transactionLong=38.3588] - Longitude coordinate of the transaction location. Defaults to 38.3588.\r",
					"     */\r",
					"\r",
					"    createQuickerTransactionSets: function (numberOfSets, debtorIdRef, debtorAccountIdRef, creditorIdRef, creditorAccountIdRef, timestampEpoch, timestampIterationLeap, timestampInterval, currency, amountRef, transactionDescriptionRef, pacs002Sts, debtorAge, transactionPurpose, transactionLat, transactionLong) {\r",
					"\r",
					"        const activePain001 = JSON.parse(_pm.environment.get('activePain001'));\r",
					"        activePain001 ? console.log(\"pain.001/013 ingestion is enabled\") : console.log(\"pain.001/013 ingestion is disabled\");\r",
					"        const arangoUrl = _pm.environment.get('arangoUrl');\r",
					"        const db_messagehistory = _pm.environment.get('db_messagehistory');\r",
					"        const db_historygraph = _pm.environment.get('db_historygraph');\r",
					"        const db_coll_graph_transactions = _pm.environment.get('db_coll_graph_transactions');\r",
					"\r",
					"        var db_coll_msg_transactionHistoryPain001;\r",
					"        var db_coll_msg_transactionHistoryPain013;\r",
					"        if (activePain001) {\r",
					"            db_coll_msg_transactionHistoryPain001 = _pm.environment.get('db_coll_msg_transactionHistoryPain001');\r",
					"            db_coll_msg_transactionHistoryPain013 = _pm.environment.get('db_coll_msg_transactionHistoryPain013');\r",
					"        }\r",
					"        const db_coll_msg_transactionHistoryPacs008 = _pm.environment.get('db_coll_msg_transactionHistoryPacs008');\r",
					"        const db_coll_msg_transactionHistoryPacs002 = _pm.environment.get('db_coll_msg_transactionHistoryPacs002');\r",
					"        const accountsPrefix = 'accounts/';\r",
					"\r",
					"        // Variables for test data parameterisation\r",
					"\r",
					"        // Essential defaults\r",
					"        numberOfSets = numberOfSets ? numberOfSets : 1;\r",
					"        timestampEpoch = timestampEpoch ? timestampEpoch : 0;\r",
					"        currency = currency ? currency : 'XTS';\r",
					"        if (numberOfSets == 1) {\r",
					"            timestampIterationLeap = 0\r",
					"        } else {\r",
					"            timestampIterationLeap = timestampIterationLeap ? timestampIterationLeap : Math.trunc(timestampEpoch / numberOfSets)\r",
					"        }\r",
					"        timestampInterval = timestampInterval ? timestampInterval : 300000; // 300,000 milliseconds = 5 minutes\r",
					"        pacs002Sts = pacs002Sts ? pacs002Sts : 'ACCC';\r",
					"        debtorAge = debtorAge ? debtorAge : 25;\r",
					"        if (activePain001) {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'TRANSFER' // or 'WITHDRAWAL', or 'PAYMENT'\r",
					"        } else {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'MP2P' // or 'MP2B', or 'CASH'\r",
					"        }\r",
					"        transactionLat = transactionLat ? transactionLat : -3.1609\r",
					"        transactionLong = transactionLong ? transactionLong : 38.3588\r",
					"\r",
					"        // Defaults\r",
					"        let debtorDoB = new Date(new Date().setDate(new Date().getDate() - (debtorAge * 366))).toISOString().substring(0, 10);\r",
					"        timestampEpochStart = timestampEpoch;\r",
					"\r",
					"        for (let step = 0; step < numberOfSets; step++) {\r",
					"            // Match incoming parameter or randomise\r",
					"            let debtorId = debtorIdRef || 'dbtr_' + uuid.v4().replace(/-/g, '') + debtorIdType;\r",
					"            let debtorAccountId = debtorAccountIdRef || 'dbtrAcct_' + uuid.v4().replace(/-/g, '') + debtorAccountType + debtorAgentId;\r",
					"            let creditorId = creditorIdRef || 'cdtr_' + uuid.v4().replace(/-/g, '') + creditorIdType;\r",
					"            let creditorAccountId = creditorAccountIdRef || 'cdtrAcct_' + uuid.v4().replace(/-/g, '') + debtorAccountType + creditorAgentId;\r",
					"\r",
					"            var debtorKey = debtorId;\r",
					"            var debtorAccountKey = debtorAccountId;\r",
					"            var creditorKey = creditorId;\r",
					"            var creditorAccountKey = creditorAccountId;\r",
					"\r",
					"            let amount = amountRef || Math.round((Math.random() * (1000 - 10) + 10) * 100) / 100;\r",
					"            let transactionDescription = transactionDescriptionRef || uuid.v4().replace(/-/g, '');\r",
					"\r",
					"            let timestampPacs008 = new Date(new Date(Date.now() - timestampEpochStart + (timestampIterationLeap * step) - timestampInterval * 1)).toISOString();\r",
					"            let timestampPacs002 = new Date(new Date(Date.now() - timestampEpochStart + (timestampIterationLeap * step) - timestampInterval * 0)).toISOString();\r",
					"\r",
					"            if (!debtorIdRef) {\r",
					"                utils.createEntity(debtorId);\r",
					"            }\r",
					"            if (!creditorIdRef) {\r",
					"                utils.createEntity(creditorId);\r",
					"            }\r",
					"            if (!debtorAccountIdRef) {\r",
					"                utils.createSingleAccount(debtorKey, debtorAccountKey, timestampPacs008);\r",
					"            }\r",
					"            if (!creditorAccountIdRef) {\r",
					"                utils.createSingleAccount(creditorKey, creditorAccountKey, timestampPacs008);\r",
					"            }\r",
					"\r",
					"            let endToEndId = uuid.v4().replace(/-/g, '');\r",
					"            let messageIdPacs008 = uuid.v4().replace(/-/g, '');\r",
					"            let messageIdPacs002 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"            var timestampPain001;\r",
					"            var timestampPain013;\r",
					"\r",
					"            var baseCreDtTm;\r",
					"            if (activePain001) {\r",
					"                timestampPain001 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 3)).toISOString();\r",
					"                timestampPain013 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 2)).toISOString();\r",
					"                baseCreDtTm = timestampPain001;\r",
					"            } else {\r",
					"                baseCreDtTm = timestampPacs008;\r",
					"            }\r",
					"\r",
					"            const dataCache = [{\r",
					"                \"dbtrId\": `${debtorKey}`,\r",
					"                \"cdtrId\": `${creditorKey}`,\r",
					"                \"dbtrAcctId\": `${debtorAccountKey}`,\r",
					"                \"cdtrAcctId\": `${creditorAccountKey}`,\r",
					"                \"creDtTm\": `${baseCreDtTm}`,\r",
					"                \"amt\": {\r",
					"                    \"amt\": amount,\r",
					"                    \"ccy\": `${currency}`\r",
					"                }\r",
					"            }];\r",
					"\r",
					"            const pacs008 = [prep.prepPacs008Msg(messageIdPacs008, timestampPacs008, endToEndId, currency, amount, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionPurpose, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"\r",
					"            const pacs002 = [prep.prepPacs002Msg(messageIdPacs002, timestampPacs002, endToEndId, pacs002Sts, dataCache)];\r",
					"\r",
					"            var messageIdPain001;\r",
					"            var messageIdPain013;\r",
					"\r",
					"            var pain001;\r",
					"            var pain013;\r",
					"\r",
					"            if (activePain001) {\r",
					"                messageIdPain001 = uuid.v4().replace(/-/g, '');\r",
					"                messageIdPain013 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"                pain001 = [prep.prepPain001Msg(messageIdPain001, timestampPain001, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, transactionPurpose, currency, amount, creditorId, creditorIdType, creditorAccountId, creditAccountType, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"\r",
					"                pain013 = [prep.prepPain013Msg(messageIdPain013, timestampPain013, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, currency, amount, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionLat, transactionLong, dataCache)];\r",
					"            }\r",
					"\r",
					"            var transactions = [];\r",
					"            var postRequests = [];\r",
					"\r",
					"            if (activePain001) {\r",
					"                transactions = prep.prepGraphTransactions(accountsPrefix, debtorAccountKey, creditorAccountKey, currency, amount, endToEndId, timestampPacs008, messageIdPacs008, timestampPacs002, messageIdPacs002, pacs002Sts, timestampPain001, messageIdPain001, timestampPain013, messageIdPain013);\r",
					"\r",
					"                postRequests = [{\r",
					"                    url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPain001}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(pain001)\r",
					"                    }\r",
					"                }, {\r",
					"                    url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPain013}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(pain013)\r",
					"                    }\r",
					"                }, {\r",
					"                    url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPacs008}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(pacs008)\r",
					"                    }\r",
					"                }, {\r",
					"                    url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPacs002}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(pacs002)\r",
					"                    }\r",
					"                }, {\r",
					"                    url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_transactions}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(transactions)\r",
					"                    }\r",
					"                }];\r",
					"            } else {\r",
					"                transactions = prep.prepGraphTransactions(accountsPrefix, debtorAccountKey, creditorAccountKey, currency, amount, endToEndId, timestampPacs008, messageIdPacs008, timestampPacs002, messageIdPacs002, pacs002Sts);\r",
					"\r",
					"                postRequests = [{\r",
					"                    url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPacs008}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(pacs008)\r",
					"                    }\r",
					"                }, {\r",
					"                    url: `${arangoUrl}/_db/${db_messagehistory}/_api/document/${db_coll_msg_transactionHistoryPacs002}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(pacs002)\r",
					"                    }\r",
					"                }, {\r",
					"                    url: `${arangoUrl}/_db/${db_historygraph}/_api/document/${db_coll_graph_transactions}`,\r",
					"                    method: 'POST',\r",
					"                    header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"                    body: {\r",
					"                        mode: 'raw',\r",
					"                        raw: JSON.stringify(transactions)\r",
					"                    }\r",
					"                }];\r",
					"            }\r",
					"\r",
					"            postRequests.forEach((postRequest) => {\r",
					"                _pm.sendRequest(postRequest, (error, response) => {\r",
					"                    console.log(error ? error : response.json());\r",
					"                });\r",
					"            });\r",
					"\r",
					"            if (activePain001) {\r",
					"                console.log(`Created transaction set ${step + 1}/${numberOfSets} from ${debtorAccountId} to ${creditorAccountId} from pain.001:${timestampPain001} to pacs.002:${timestampPacs002} with EndToEndId ${endToEndId}`);\r",
					"            } else {\r",
					"                console.log(`Created transaction set ${step + 1}/${numberOfSets} from ${debtorAccountId} to ${creditorAccountId} from pacs.008:${timestampPacs008} to pacs.002${timestampPacs002} with EndToEndId ${endToEndId}`);\r",
					"            }\r",
					"\r",
					"        }\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Creates a new set of transactions for testing purposes, including all necessary data, and stores it in memory so that the transactions can be submitted to the API in sequence as valid messages.\r",
					"     * The transaction sets will include pain.001/013 messages if the environment variable activePain001 = true.\r",
					"     * The transaction set will contain a pacs.008 and a pacs.002 message.\r",
					"     * The messages in the set will be linked through the same EndToEndId.\r",
					"     * The function stashes created data in global variables can be retrieved with the `pm.globals.get()` method.\r",
					"     *\r",
					"     * @param {number|null|undefined} [timestampEpoch=0] - Epoch timestamp for adjusting transaction timestamps. Defaults to 0.\r",
					"     * @param {string|null|undefined} [currency='XTS'] - Currency code for the transaction amount. Defaults to 'XTS'.\r",
					"     * @param {number|null|undefined} [amount] - Transaction amount. Defaults to a random value between 10 and 1000.\r",
					"     * @param {string|null|undefined} [transactionDescription='Generic payment description'] - Description of the transaction. Defaults to 'Generic payment description'.\r",
					"     * @param {string|null|undefined} [pacs002Sts='ACCC'] - Transaction status for pacs.002.001.12 message. Defaults to 'ACCC' (a successful transaction).\r",
					"     * @param {number|null|undefined} [debtorAge=25] - Age of the debtor. Defaults to 25.\r",
					"     * @param {string|null|undefined} [transactionPurpose] - Purpose of the transaction. Defaults to 'TRANSFER' if pain.001/013 ingestion is enabled, otherwise 'MP2P'.\r",
					"     * @param {number|null|undefined} [transactionLat=-3.1609] - Latitude coordinate of the transaction location. Defaults to -3.1609.\r",
					"     * @param {number|null|undefined} [transactionLong=38.3588] - Longitude coordinate of the transaction location. Defaults to 38.3588.\r",
					"     */\r",
					"\r",
					"    createNewTransactionSetInMemory: function (timestampEpoch, currency, amount, transactionDescription, pacs002Sts, debtorAge, transactionPurpose, transactionLat, transactionLong) {\r",
					"\r",
					"        // Variables for test data parameterisation\r",
					"        const activePain001 = JSON.parse(_pm.environment.get('activePain001'));\r",
					"        activePain001 ? console.log(\"pain.001/013 ingestion is enabled\") : console.log(\"pain.001/013 ingestion is disabled\");\r",
					"\r",
					"        // Essential defaults\r",
					"        timestampEpoch = timestampEpoch ? timestampEpoch : 0;\r",
					"        currency = currency ? currency : 'XTS';\r",
					"        amount = amount ? amount : Math.round((Math.random() * (1000 - 10) + 10) * 100) / 100;\r",
					"        transactionDescription = transactionDescription ? transactionDescription : 'Generic payment description';\r",
					"        pacs002Sts = pacs002Sts ? pacs002Sts : 'ACCC';\r",
					"        debtorAge = debtorAge ? debtorAge : 25;\r",
					"        if (activePain001) {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'TRANSFER' // or 'WITHDRAWAL', or 'PAYMENT'\r",
					"        } else {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'MP2P' // or 'MP2B', or 'CASH'\r",
					"        }\r",
					"        transactionLat = transactionLat ? transactionLat : -3.1609\r",
					"        transactionLong = transactionLong ? transactionLong : 38.3588\r",
					"\r",
					"        // Defaults\r",
					"        const timestampInterval = 300000; // 300,000 milliseconds = 5 minutes\r",
					"        let debtorId = uuid.v4().replace(/-/g, '');\r",
					"        let debtorAccountId = uuid.v4().replace(/-/g, '');\r",
					"        let creditorId = uuid.v4().replace(/-/g, '');\r",
					"        let creditorAccountId = uuid.v4().replace(/-/g, '');\r",
					"        let debtorDoB = new Date(new Date().setDate(new Date().getDate() - (debtorAge * 366))).toISOString().substring(0, 10);\r",
					"        let timestampPacs008 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 1)).toISOString();\r",
					"        let timestampPacs002 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 0)).toISOString();\r",
					"        console.log(\"pacs.002 payload timestamp: \" + timestampPacs002);\r",
					"        let endToEndId = uuid.v4().replace(/-/g, '');\r",
					"        let messageIdPacs008 = uuid.v4().replace(/-/g, '');\r",
					"        let messageIdPacs002 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"        var timestampPain001;\r",
					"        var timestampPain013;\r",
					"        var messageIdPain001;\r",
					"        var messageIdPain013;\r",
					"\r",
					"        var pain001;\r",
					"        var pain013;\r",
					"        var baseCreDtTm;\r",
					"        if (activePain001) {\r",
					"            timestampPain001 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 3)).toISOString();\r",
					"            timestampPain013 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 2)).toISOString();\r",
					"            baseCreDtTm = timestampPain001;\r",
					"        } else {\r",
					"            baseCreDtTm = timestampPacs008;\r",
					"        }\r",
					"\r",
					"        var debtorKey = debtorId + debtorIdType;\r",
					"        var debtorAccountKey = debtorAccountId + debtorAccountType + debtorAgentId;\r",
					"        var creditorKey = creditorId + creditorIdType;\r",
					"        var creditorAccountKey = creditorAccountId + debtorAccountType + creditorAgentId;\r",
					"\r",
					"        const dataCache = [{\r",
					"            \"dbtrId\": `${debtorKey}`,\r",
					"            \"cdtrId\": `${creditorKey}`,\r",
					"            \"dbtrAcctId\": `${debtorAccountKey}`,\r",
					"            \"cdtrAcctId\": `${creditorAccountKey}`,\r",
					"            \"creDtTm\": `${baseCreDtTm}`,\r",
					"            \"amt\": {\r",
					"                \"amt\": amount,\r",
					"                \"ccy\": `${currency}`\r",
					"            }\r",
					"        }];\r",
					"\r",
					"        if (activePain001) {\r",
					"            messageIdPain001 = uuid.v4().replace(/-/g, '');\r",
					"            messageIdPain013 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"            pain001 = [prep.prepPain001Msg(messageIdPain001, timestampPain001, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, transactionPurpose, currency, amount, creditorId, creditorIdType, creditorAccountId, creditAccountType, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"\r",
					"            pain013 = [prep.prepPain013Msg(messageIdPain013, timestampPain013, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, currency, amount, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionLat, transactionLong, dataCache)];\r",
					"        }\r",
					"\r",
					"        const pacs008 = [prep.prepPacs008Msg(messageIdPacs008, timestampPacs008, endToEndId, currency, amount, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionPurpose, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"        //let deleteTxTp = lodash.unset(pacs008[0],\"TxTp\");\r",
					"\r",
					"        const pacs002 = [prep.prepPacs002Msg(messageIdPacs002, timestampPacs002, endToEndId, pacs002Sts, dataCache)];\r",
					"\r",
					"        console.log('pacs.008 message: ' + JSON.stringify(pacs008[0]));\r",
					"        console.log('pacs.002 trigger payload: ' + JSON.stringify(pacs002[0]));\r",
					"\r",
					"        _pm.globals.set(\"pacs008\", JSON.stringify(pacs008[0]));\r",
					"        _pm.globals.set(\"pacs002\", JSON.stringify(pacs002[0]));\r",
					"        _pm.globals.set(\"dataCache\", JSON.stringify(dataCache[0]));\r",
					"        _pm.globals.set('debtorId', debtorId);\r",
					"        _pm.globals.set('debtorAccountId', debtorAccountId);\r",
					"        _pm.globals.set('debtorDoB', debtorDoB);\r",
					"        _pm.globals.set('creditorId', creditorId);\r",
					"        _pm.globals.set('creditorAccountId', creditorAccountId);\r",
					"        _pm.globals.set('timestampPacs008', timestampPacs008);\r",
					"        _pm.globals.set('timestampPacs002', timestampPacs002);\r",
					"        _pm.globals.set('endToEndId', endToEndId);\r",
					"        _pm.globals.set('pacs002Sts', pacs002Sts);\r",
					"        _pm.globals.set('currency', currency);\r",
					"        _pm.globals.set('amount', amount);\r",
					"        _pm.globals.set('transactionDescription', transactionDescription);\r",
					"        _pm.globals.set('transactionPurpose', transactionPurpose);\r",
					"        _pm.globals.set('transactionLat', transactionLat);\r",
					"        _pm.globals.set('transactionLong', transactionLong);\r",
					"        _pm.globals.set('messageIdPacs008', messageIdPacs008);\r",
					"        _pm.globals.set('messageIdPacs002', messageIdPacs002);\r",
					"        _pm.globals.set('baseTimestamp', timestampPacs008);\r",
					"        _pm.globals.set('debtorKey', debtorKey);\r",
					"        _pm.globals.set('debtorAccountKey', debtorAccountKey);\r",
					"        _pm.globals.set('creditorKey', creditorKey);\r",
					"        _pm.globals.set('creditorAccountKey', creditorAccountKey);\r",
					"        if (activePain001) {\r",
					"            _pm.globals.set(\"pain001\", JSON.stringify(pain001[0]));\r",
					"            _pm.globals.set(\"pain013\", JSON.stringify(pain013[0]));\r",
					"            _pm.globals.set('timestampPain001', timestampPain001);\r",
					"            _pm.globals.set('timestampPain013', timestampPain013);\r",
					"            _pm.globals.set('messageIdPain001', messageIdPain001);\r",
					"            _pm.globals.set('messageIdPain013', messageIdPain013);\r",
					"            _pm.globals.set('baseTimestamp', timestampPain001);\r",
					"        }\r",
					"\r",
					"        this.logDataCache(dataCache[0]);\r",
					"\r",
					"        if (activePain001) {\r",
					"            console.log(`Message IDs:\r",
					"                pain.001: ${_pm.globals.get(\"messageIdPain001\")}\",\r",
					"                pain.013: ${_pm.globals.get(\"messageIdPain013\")}\",\r",
					"                pacs.008: ${_pm.globals.get(\"messageIdPacs008\")}\",\r",
					"                pacs.002: ${_pm.globals.get(\"messageIdPacs002\")}\"\r",
					"            `);\r",
					"        } else {\r",
					"            console.log(`Message IDs:\r",
					"                pain.001: disabled\",\r",
					"                pain.013: disabled\",\r",
					"                pacs.008: ${_pm.globals.get(\"messageIdPacs008\")}\",\r",
					"                pacs.002: ${_pm.globals.get(\"messageIdPacs002\")}\"\r",
					"            `);\r",
					"        }\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Creates an additional set of transactions for testing purposes, including all necessary data, and stores it in memory so that the transactions can be submitted to the API in sequence as valid messages.\r",
					"     * The transaction sets will include pain.001/013 messages if the environment variable activePain001 = true.\r",
					"     * The transaction set will contain a pacs.008 and a pacs.002 message.\r",
					"     * The messages in the set will be linked through the same EndToEndId.\r",
					"     * The function stashes created data in global variables can be retrieved with the `pm.globals.get()` method.\r",
					"     *\r",
					"     * @param {string|null|undefined} [debtorIdRef=null] - Reference identifier for the debtor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.\r",
					"     * @param {string|null|undefined} [debtorAccountIdRef=null] - Reference account identifier for the debtor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.\r",
					"     * @param {string|null|undefined} [creditorIdRef=null] - Reference identifier for the creditor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.\r",
					"     * @param {string|null|undefined} [creditorAccountIdRef=null] - Reference account identifier for the creditor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.\r",
					"     * @param {number|null|undefined} [timestampEpoch=0] - Epoch timestamp for adjusting transaction timestamps. Defaults to 0.\r",
					"     * @param {string|null|undefined} [currency='XTS'] - Currency code for the transaction amount. Defaults to 'XTS'.\r",
					"     * @param {number|null|undefined} [amount] - Transaction amount. Defaults to a random value between 10 and 1000.\r",
					"     * @param {string|null|undefined} [transactionDescription='Generic payment description'] - Description of the transaction. Defaults to 'Generic payment description'.\r",
					"     * @param {string|null|undefined} [pacs002Sts='ACCC'] - Transaction status for pacs.002.001.12 message. Defaults to 'ACCC' (a successful transaction).\r",
					"     * @param {number|null|undefined} [debtorAge=25] - Age of the debtor. Defaults to 25.\r",
					"     * @param {string|null|undefined} [transactionPurpose] - Purpose of the transaction. Defaults to 'TRANSFER' if pain.001/013 ingestion is enabled, otherwise 'MP2P'.\r",
					"     * @param {number|null|undefined} [transactionLat=-3.1609] - Latitude coordinate of the transaction location. Defaults to -3.1609.\r",
					"     * @param {number|null|undefined} [transactionLong=38.3588] - Longitude coordinate of the transaction location. Defaults to 38.3588.\r",
					"     */\r",
					"\r",
					"    createAdditionalTransactionSetInMemory: function (debtorIdRef, debtorAccountIdRef, creditorIdRef, creditorAccountIdRef, timestampEpoch, currency, amount, transactionDescription, pacs002Sts, debtorAge, transactionPurpose, transactionLat, transactionLong) {\r",
					"\r",
					"        // Variables for test data parameterisation\r",
					"        const activePain001 = JSON.parse(_pm.environment.get('activePain001'));\r",
					"        activePain001 ? console.log(\"pain.001/013 ingestion is enabled\") : console.log(\"pain.001/013 ingestion is disabled\");\r",
					"\r",
					"        // Essential defaults\r",
					"        timestampEpoch = timestampEpoch ? timestampEpoch : 0;\r",
					"        currency = currency ? currency : 'XTS';\r",
					"        amount = amount ? amount : Math.round((Math.random() * (1000 - 10) + 10) * 100) / 100;\r",
					"        transactionDescription = transactionDescription ? transactionDescription : 'Generic payment description';\r",
					"        pacs002Sts = pacs002Sts ? pacs002Sts : 'ACCC';\r",
					"        debtorAge = debtorAge ? debtorAge : 25;\r",
					"        if (activePain001) {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'TRANSFER' // or 'WITHDRAWAL', or 'PAYMENT'\r",
					"        } else {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'MP2P' // or 'MP2B', or 'CASH'\r",
					"        }\r",
					"        transactionLat = transactionLat ? transactionLat : -3.1609\r",
					"        transactionLong = transactionLong ? transactionLong : 38.3588\r",
					"\r",
					"        // Defaults\r",
					"        const timestampInterval = 300000; // 300,000 milliseconds = 5 minutes\r",
					"\r",
					"        let debtorId = debtorIdRef || 'dbtr_' + uuid.v4().replace(/-/g, '') + debtorIdType;\r",
					"        let debtorAccountId = debtorAccountIdRef || 'dbtrAcct_' + uuid.v4().replace(/-/g, '') + debtorAccountType + debtorAgentId;\r",
					"        let creditorId = creditorIdRef || 'cdtr_' + uuid.v4().replace(/-/g, '') + creditorIdType;\r",
					"        let creditorAccountId = creditorAccountIdRef || 'cdtrAcct_' + uuid.v4().replace(/-/g, '') + debtorAccountType + creditorAgentId;\r",
					"\r",
					"        var debtorKey = debtorId;\r",
					"        var debtorAccountKey = debtorAccountId;\r",
					"        var creditorKey = creditorId;\r",
					"        var creditorAccountKey = creditorAccountId;\r",
					"\r",
					"        let debtorDoB = new Date(new Date().setDate(new Date().getDate() - (debtorAge * 366))).toISOString().substring(0, 10);\r",
					"        let timestampPacs008 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 1)).toISOString();\r",
					"        let timestampPacs002 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 0)).toISOString();\r",
					"        console.log(\"pacs.002 payload timestamp: \" + timestampPacs002);\r",
					"        let endToEndId = uuid.v4().replace(/-/g, '');\r",
					"        let messageIdPacs008 = uuid.v4().replace(/-/g, '');\r",
					"        let messageIdPacs002 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"        var timestampPain001;\r",
					"        var timestampPain013;\r",
					"        var messageIdPain001;\r",
					"        var messageIdPain013;\r",
					"\r",
					"        var pain001;\r",
					"        var pain013;\r",
					"        var baseCreDtTm;\r",
					"        if (activePain001) {\r",
					"            timestampPain001 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 3)).toISOString();\r",
					"            timestampPain013 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 2)).toISOString();\r",
					"            baseCreDtTm = timestampPain001;\r",
					"        } else {\r",
					"            baseCreDtTm = timestampPacs008;\r",
					"        }\r",
					"\r",
					"        const dataCache = [{\r",
					"            \"dbtrId\": `${debtorKey}`,\r",
					"            \"cdtrId\": `${creditorKey}`,\r",
					"            \"dbtrAcctId\": `${debtorAccountKey}`,\r",
					"            \"cdtrAcctId\": `${creditorAccountKey}`,\r",
					"            \"creDtTm\": `${baseCreDtTm}`,\r",
					"            \"amt\": {\r",
					"                \"amt\": amount,\r",
					"                \"ccy\": `${currency}`\r",
					"            }\r",
					"        }];\r",
					"\r",
					"        if (activePain001) {\r",
					"            messageIdPain001 = uuid.v4().replace(/-/g, '');\r",
					"            messageIdPain013 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"            pain001 = [prep.prepPain001Msg(messageIdPain001, timestampPain001, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, transactionPurpose, currency, amount, creditorId, creditorIdType, creditorAccountId, creditAccountType, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"\r",
					"            pain013 = [prep.prepPain013Msg(messageIdPain013, timestampPain013, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, currency, amount, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionLat, transactionLong, dataCache)];\r",
					"        }\r",
					"\r",
					"        const pacs008 = [prep.prepPacs008Msg(messageIdPacs008, timestampPacs008, endToEndId, currency, amount, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionPurpose, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"        let deleteTxTp = lodash.unset(pacs008[0], \"TxTp\");\r",
					"\r",
					"        const pacs002 = [prep.prepPacs002Msg(messageIdPacs002, timestampPacs002, endToEndId, pacs002Sts, dataCache)];\r",
					"\r",
					"        console.log('pacs.002 trigger payload: ' + JSON.stringify(pacs002[0]));\r",
					"\r",
					"        _pm.globals.set(\"pacs008\", JSON.stringify(pacs008[0]));\r",
					"        _pm.globals.set(\"pacs002\", JSON.stringify(pacs002[0]));\r",
					"        _pm.globals.set(\"dataCache\", JSON.stringify(dataCache[0]));\r",
					"        _pm.globals.set('debtorId', debtorId);\r",
					"        _pm.globals.set('debtorAccountId', debtorAccountId);\r",
					"        _pm.globals.set('debtorDoB', debtorDoB);\r",
					"        _pm.globals.set('creditorId', creditorId);\r",
					"        _pm.globals.set('creditorAccountId', creditorAccountId);\r",
					"        _pm.globals.set('timestampPacs008', timestampPacs008);\r",
					"        _pm.globals.set('timestampPacs002', timestampPacs002);\r",
					"        _pm.globals.set('endToEndId', endToEndId);\r",
					"        _pm.globals.set('pacs002Sts', pacs002Sts);\r",
					"        _pm.globals.set('currency', currency);\r",
					"        _pm.globals.set('amount', amount);\r",
					"        _pm.globals.set('transactionDescription', transactionDescription);\r",
					"        _pm.globals.set('transactionPurpose', transactionPurpose);\r",
					"        _pm.globals.set('transactionLat', transactionLat);\r",
					"        _pm.globals.set('transactionLong', transactionLong);\r",
					"        _pm.globals.set('messageIdPacs008', messageIdPacs008);\r",
					"        _pm.globals.set('messageIdPacs002', messageIdPacs002);\r",
					"        _pm.globals.set('baseTimestamp', timestampPacs008);\r",
					"        _pm.globals.set('debtorKey', debtorKey);\r",
					"        _pm.globals.set('debtorAccountKey', debtorAccountKey);\r",
					"        _pm.globals.set('creditorKey', creditorKey);\r",
					"        _pm.globals.set('creditorAccountKey', creditorAccountKey);\r",
					"        if (activePain001) {\r",
					"            _pm.globals.set(\"pain001\", JSON.stringify(pain001[0]));\r",
					"            _pm.globals.set(\"pain013\", JSON.stringify(pain013[0]));\r",
					"            _pm.globals.set('timestampPain001', timestampPain001);\r",
					"            _pm.globals.set('timestampPain013', timestampPain013);\r",
					"            _pm.globals.set('messageIdPain001', messageIdPain001);\r",
					"            _pm.globals.set('messageIdPain013', messageIdPain013);\r",
					"            _pm.globals.set('baseTimestamp', timestampPain001);\r",
					"        }\r",
					"\r",
					"        this.logDataCache(dataCache[0]);\r",
					"\r",
					"        if (activePain001) {\r",
					"            console.log(`Message IDs:\r",
					"                pain.001: ${_pm.globals.get(\"messageIdPain001\")}\",\r",
					"                pain.013: ${_pm.globals.get(\"messageIdPain013\")}\",\r",
					"                pacs.008: ${_pm.globals.get(\"messageIdPacs008\")}\",\r",
					"                pacs.002: ${_pm.globals.get(\"messageIdPacs002\")}\"\r",
					"            `);\r",
					"        } else {\r",
					"            console.log(`Message IDs:\r",
					"                pain.001: disabled\",\r",
					"                pain.013: disabled\",\r",
					"                pacs.008: ${_pm.globals.get(\"messageIdPacs008\")}\",\r",
					"                pacs.002: ${_pm.globals.get(\"messageIdPacs002\")}\"\r",
					"            `);\r",
					"        }\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Creates a new PACS.008 transaction with all associated details and identifiers.\r",
					"     *\r",
					"     * @param {number|null|undefined} [timestampEpoch=0] - Epoch timestamp for adjusting transaction timestamps.\r",
					"     * @param {string|null|undefined} [currency='XTS'] - Currency code for the transaction.\r",
					"     * @param {number|null|undefined} [amount=random value] - Transaction amount, defaults to a random value between 10 and 1000.\r",
					"     * @param {string|null|undefined} [transactionDescription='Generic payment description'] - Description of the transaction.\r",
					"     * @param {string|null|undefined} [pacs002Sts='ACCC'] - Status for the PACS.002 message.\r",
					"     * @param {number|null|undefined} [debtorAge=25] - Age of the debtor.\r",
					"     * @param {string|null|undefined} [transactionPurpose='TRANSFER' or 'MP2P'] - Purpose of the transaction, defaults based on whether pain.001/013 ingestion is active.\r",
					"     * @param {number|null|undefined} [transactionLat=-3.1609] - Latitude of the transaction's location.\r",
					"     * @param {number|null|undefined} [transactionLong=38.3588] - Longitude of the transaction's location.\r",
					"     * @returns {Object} The created PACS.008 transaction object.\r",
					"     */\r",
					"\r",
					"    createNewPacs008Transaction: function (timestampEpoch, currency, amount, transactionDescription, pacs002Sts, debtorAge, transactionPurpose, transactionLat, transactionLong) {\r",
					"\r",
					"\r",
					"        // Variables for test data parameterisation\r",
					"        const activePain001 = JSON.parse(_pm.environment.get('activePain001'));\r",
					"\r",
					"        // Essential defaults\r",
					"        timestampEpoch = timestampEpoch ? timestampEpoch : 0;\r",
					"        currency = currency ? currency : 'XTS';\r",
					"        amount = amount ? amount : Math.round((Math.random() * (1000 - 10) + 10) * 100) / 100;\r",
					"        transactionDescription = transactionDescription ? transactionDescription : 'Generic payment description';\r",
					"        pacs002Sts = pacs002Sts ? pacs002Sts : 'ACCC';\r",
					"        debtorAge = debtorAge ? debtorAge : 25;\r",
					"        if (activePain001) {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'TRANSFER' // or 'WITHDRAWAL', or 'PAYMENT'\r",
					"        } else {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'MP2P' // or 'MP2B', or 'CASH'\r",
					"        }\r",
					"        transactionLat = transactionLat ? transactionLat : -3.1609\r",
					"        transactionLong = transactionLong ? transactionLong : 38.3588\r",
					"\r",
					"        // Defaults\r",
					"        const timestampInterval = 300000; // 300,000 milliseconds = 5 minutes\r",
					"        let debtorId = uuid.v4().replace(/-/g, '');\r",
					"        let debtorAccountId = uuid.v4().replace(/-/g, '');\r",
					"        let creditorId = uuid.v4().replace(/-/g, '');\r",
					"        let creditorAccountId = uuid.v4().replace(/-/g, '');\r",
					"        let debtorDoB = new Date(new Date().setDate(new Date().getDate() - (debtorAge * 366))).toISOString().substring(0, 10);\r",
					"        let timestampPacs008 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 1)).toISOString();\r",
					"        let timestampPacs002 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 0)).toISOString();\r",
					"        let endToEndId = uuid.v4().replace(/-/g, '');\r",
					"        let messageIdPacs008 = uuid.v4().replace(/-/g, '');\r",
					"        let messageIdPacs002 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"        var timestampPain001;\r",
					"        var timestampPain013;\r",
					"        var messageIdPain001;\r",
					"        var messageIdPain013;\r",
					"\r",
					"        var pain001;\r",
					"        var pain013;\r",
					"        var baseCreDtTm;\r",
					"        const dataCache = [{}];\r",
					"\r",
					"        if (activePain001) {\r",
					"            timestampPain001 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 3)).toISOString();\r",
					"            timestampPain013 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 2)).toISOString();\r",
					"            messageIdPain001 = uuid.v4().replace(/-/g, '');\r",
					"            messageIdPain013 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"            pain001 = [prep.prepPain001Msg(messageIdPain001, timestampPain001, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, transactionPurpose, currency, amount, creditorId, creditorIdType, creditorAccountId, creditAccountType, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"\r",
					"            pain013 = [prep.prepPain013Msg(messageIdPain013, timestampPain013, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, currency, amount, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionLat, transactionLong, dataCache)];\r",
					"            baseCreDtTm = timestampPain001;\r",
					"        } else {\r",
					"            baseCreDtTm = timestampPacs008;\r",
					"        }\r",
					"\r",
					"        const pacs008 = [prep.prepPacs008Msg(messageIdPacs008, timestampPacs008, endToEndId, currency, amount, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionPurpose, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"\r",
					"        const pacs002 = [prep.prepPacs002Msg(messageIdPacs002, timestampPacs002, endToEndId, pacs002Sts, dataCache)];\r",
					"\r",
					"        let deleteDataCache = lodash.unset(pacs008[0], \"DataCache\");\r",
					"\r",
					"        return pacs008[0];\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Creates a new PACS.002 transaction with all associated details and identifiers.\r",
					"     *\r",
					"     * @param {number|null|undefined} [timestampEpoch=0] - Epoch timestamp for adjusting transaction timestamps.\r",
					"     * @param {string|null|undefined} [currency='XTS'] - Currency code for the transaction.\r",
					"     * @param {number|null|undefined} [amount=random value] - Transaction amount, defaults to a random value between 10 and 1000.\r",
					"     * @param {string|null|undefined} [transactionDescription='Generic payment description'] - Description of the transaction.\r",
					"     * @param {string|null|undefined} [pacs002Sts='ACCC'] - Status for the PACS.002 message.\r",
					"     * @param {number|null|undefined} [debtorAge=25] - Age of the debtor.\r",
					"     * @param {string|null|undefined} [transactionPurpose='TRANSFER' or 'MP2P'] - Purpose of the transaction, defaults based on whether pain.001/013 ingestion is active.\r",
					"     * @param {number|null|undefined} [transactionLat=-3.1609] - Latitude of the transaction's location.\r",
					"     * @param {number|null|undefined} [transactionLong=38.3588] - Longitude of the transaction's location.\r",
					"     * @returns {Object} The created PACS.002 transaction object.\r",
					"     */\r",
					"\r",
					"    createNewPacs002Transaction: function (timestampEpoch, currency, amount, transactionDescription, pacs002Sts, debtorAge, transactionPurpose, transactionLat, transactionLong) {\r",
					"\r",
					"\r",
					"        // Variables for test data parameterisation\r",
					"        const activePain001 = JSON.parse(_pm.environment.get('activePain001'));\r",
					"\r",
					"        // Essential defaults\r",
					"        timestampEpoch = timestampEpoch ? timestampEpoch : 0;\r",
					"        currency = currency ? currency : 'XTS';\r",
					"        amount = amount ? amount : Math.round((Math.random() * (1000 - 10) + 10) * 100) / 100;\r",
					"        transactionDescription = transactionDescription ? transactionDescription : 'Generic payment description';\r",
					"        pacs002Sts = pacs002Sts ? pacs002Sts : 'ACCC';\r",
					"        debtorAge = debtorAge ? debtorAge : 25;\r",
					"        if (activePain001) {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'TRANSFER' // or 'WITHDRAWAL', or 'PAYMENT'\r",
					"        } else {\r",
					"            transactionPurpose = transactionPurpose ? transactionPurpose : 'MP2P' // or 'MP2B', or 'CASH'\r",
					"        }\r",
					"        transactionLat = transactionLat ? transactionLat : -3.1609\r",
					"        transactionLong = transactionLong ? transactionLong : 38.3588\r",
					"\r",
					"        // Defaults\r",
					"        const timestampInterval = 300000; // 300,000 milliseconds = 5 minutes\r",
					"        let debtorId = uuid.v4().replace(/-/g, '');\r",
					"        let debtorAccountId = uuid.v4().replace(/-/g, '');\r",
					"        let creditorId = uuid.v4().replace(/-/g, '');\r",
					"        let creditorAccountId = uuid.v4().replace(/-/g, '');\r",
					"        let debtorDoB = new Date(new Date().setDate(new Date().getDate() - (debtorAge * 366))).toISOString().substring(0, 10);\r",
					"        let timestampPacs008 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 1)).toISOString();\r",
					"        let timestampPacs002 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 0)).toISOString();\r",
					"        let endToEndId = uuid.v4().replace(/-/g, '');\r",
					"        let messageIdPacs008 = uuid.v4().replace(/-/g, '');\r",
					"        let messageIdPacs002 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"        var timestampPain001;\r",
					"        var timestampPain013;\r",
					"        var messageIdPain001;\r",
					"        var messageIdPain013;\r",
					"\r",
					"        var pain001;\r",
					"        var pain013;\r",
					"        var baseCreDtTm;\r",
					"        const dataCache = [{}];\r",
					"\r",
					"        if (activePain001) {\r",
					"            timestampPain001 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 3)).toISOString();\r",
					"            timestampPain013 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 2)).toISOString();\r",
					"            messageIdPain001 = uuid.v4().replace(/-/g, '');\r",
					"            messageIdPain013 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"            pain001 = [prep.prepPain001Msg(messageIdPain001, timestampPain001, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, transactionPurpose, currency, amount, creditorId, creditorIdType, creditorAccountId, creditAccountType, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"\r",
					"            pain013 = [prep.prepPain013Msg(messageIdPain013, timestampPain013, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, endToEndId, currency, amount, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionLat, transactionLong, dataCache)];\r",
					"            baseCreDtTm = timestampPain001;\r",
					"        } else {\r",
					"            baseCreDtTm = timestampPacs008;\r",
					"        }\r",
					"\r",
					"        const pacs008 = [prep.prepPacs008Msg(messageIdPacs008, timestampPacs008, endToEndId, currency, amount, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountType, creditorId, creditorIdType, creditorAccountId, creditorAccountType, transactionPurpose, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"\r",
					"        const pacs002 = [prep.prepPacs002Msg(messageIdPacs002, timestampPacs002, endToEndId, pacs002Sts, dataCache)];\r",
					"\r",
					"        let deleteDataCache = lodash.unset(pacs002[0], \"DataCache\");\r",
					"\r",
					"        return pacs002[0];\r",
					"    },\r",
					"\r",
					"    getRuleBody: function (ruleId, ruleCfgVer, messageBody, dataCache) {\r",
					"        return utils.getRuleProcessorBody(ruleId, ruleCfgVer, messageBody, dataCache);\r",
					"    },\r",
					"\r",
					"    getRuleProcessorBody: function (ruleId, ruleCfgVer, messageBody, dataCache, collectFrom) {\r",
					"        ruleId = ruleId ? ruleId : '901@1.0.0';\r",
					"        ruleCfgVer = ruleCfgVer ? ruleCfgVer : '1.0.0';\r",
					"        const natsSub = `sub-rule-${ruleId}`;\r",
					"        const natsPub = collectFrom ? collectFrom : `pub-rule-${ruleId}`;\r",
					"        const msgId = messageBody.FIToFIPmtSts.GrpHdr.MsgId;\r",
					"        return JSON.stringify({\r",
					"            \"destination\": natsSub,\r",
					"            \"consumer\": natsPub,\r",
					"            \"functionName\": msgId,\r",
					"            \"message\": {\r",
					"                \"transaction\": messageBody,\r",
					"                \"DataCache\": dataCache,\r",
					"                \"networkMap\": {\r",
					"                    \"name\": \"Rule processor ingestion\",\r",
					"                    \"active\": true,\r",
					"                    \"cfg\": \"1.0.0\",\r",
					"                    \"messages\": [\r",
					"                        {\r",
					"                            \"id\": \"004@1.0.0\",\r",
					"                            \"cfg\": \"1.0.0\",\r",
					"                            \"txTp\": \"pacs.002.001.12\",\r",
					"                            \"typologies\": [\r",
					"                                {\r",
					"                                    \"id\": \"typology-processor@1.0.0\",\r",
					"                                    \"cfg\": \"999@1.0.0\",\r",
					"                                    \"rules\": [\r",
					"                                        {\r",
					"                                            \"id\": ruleId,\r",
					"                                            \"cfg\": ruleCfgVer\r",
					"                                        }\r",
					"                                    ]\r",
					"                                }\r",
					"                            ]\r",
					"                        }\r",
					"                    ]\r",
					"                },\r",
					"                \"metaData\": {\r",
					"                    \"prcgTmDP\": 999,\r",
					"                    \"prcgTmED\": 999,\r",
					"                    \"traceParent\": `00-postman-${msgId}-01`\r",
					"                }\r",
					"            }\r",
					"        });\r",
					"    },\r",
					"\r",
					"    getTypologyProcessorBody: function (ruleResult, typologyCfg, messageBody, dataCache, collectFrom) {\r",
					"        ruleResult = ruleResult ? ruleResult : { id: '901@1.0.0', cfg: '1.0.0', subRuleRef: '.01', prcgTm: 999 };\r",
					"        typologyCfg = typologyCfg ? typologyCfg : '999@1.0.0';\r",
					"        const natsSub = `pub-rule-${ruleResult.id}`;\r",
					"        const natsPub = collectFrom ? collectFrom : `typology-${typologyCfg}`;\r",
					"        const msgId = messageBody.FIToFIPmtSts.GrpHdr.MsgId;\r",
					"        return JSON.stringify({\r",
					"            \"destination\": natsSub,\r",
					"            \"consumer\": natsPub,\r",
					"            \"functionName\": msgId,\r",
					"            \"message\": {\r",
					"                \"transaction\": messageBody,\r",
					"                \"DataCache\": dataCache,\r",
					"                \"networkMap\": {\r",
					"                    \"name\": \"Typology processor ingestion\",\r",
					"                    \"active\": true,\r",
					"                    \"cfg\": \"1.0.0\",\r",
					"                    \"messages\": [\r",
					"                        {\r",
					"                            \"id\": \"004@1.0.0\",\r",
					"                            \"cfg\": \"1.0.0\",\r",
					"                            \"txTp\": \"pacs.002.001.12\",\r",
					"                            \"typologies\": [\r",
					"                                {\r",
					"                                    \"id\": \"typology-processor@1.0.0\",\r",
					"                                    \"cfg\": typologyCfg,\r",
					"                                    \"rules\": [\r",
					"                                        {\r",
					"                                            \"id\": ruleResult.id,\r",
					"                                            \"cfg\": ruleResult.cfg\r",
					"                                        }\r",
					"                                    ]\r",
					"                                }\r",
					"                            ]\r",
					"                        }\r",
					"                    ]\r",
					"                },\r",
					"                \"metaData\": {\r",
					"                    \"prcgTmDP\": 999,\r",
					"                    \"prcgTmED\": 999,\r",
					"                    \"traceParent\": `00-postman-${msgId}-01`\r",
					"                },\r",
					"                ruleResult\r",
					"            }\r",
					"        });\r",
					"    },\r",
					"\r",
					"    getTADProcBody: function (typologyResult, messageBody, dataCache) {\r",
					"        typologyResult = typologyResult ? typologyResult : {\r",
					"            \"id\": \"typology-processor@1.0.0\",\r",
					"            \"cfg\": \"999@1.0.0\",\r",
					"            \"result\": 100,\r",
					"            \"ruleResults\": [\r",
					"                {\r",
					"                    \"id\": \"901@1.0.0\",\r",
					"                    \"cfg\": \"1.0.0\",\r",
					"                    \"subRuleRef\": \".01\",\r",
					"                    \"prcgTm\": 999,\r",
					"                    \"wght\": 100\r",
					"                }\r",
					"            ],\r",
					"            \"prcgTm\": 999,\r",
					"            \"review\": false,\r",
					"            \"workflow\": {\r",
					"                \"alertThreshold\": 200,\r",
					"                \"interdictionThreshold\": 400\r",
					"            }\r",
					"        };\r",
					"        const typologyCfg = typologyResult.cfg;\r",
					"        const ruleResult = typologyResult.ruleResults;\r",
					"        const natsPub = `typology-${typologyCfg}`;\r",
					"        const natsSub = `cms`;\r",
					"        const msgId = messageBody.FIToFIPmtSts.GrpHdr.MsgId;\r",
					"        return JSON.stringify({\r",
					"            \"destination\": natsPub,\r",
					"            \"consumer\": natsSub,\r",
					"            \"functionName\": msgId,\r",
					"            \"message\": {\r",
					"                \"transaction\": messageBody,\r",
					"                \"DataCache\": dataCache,\r",
					"                \"networkMap\": {\r",
					"                    \"name\": \"Typology processor ingestion\",\r",
					"                    \"active\": true,\r",
					"                    \"cfg\": \"1.0.0\",\r",
					"                    \"messages\": [\r",
					"                        {\r",
					"                            \"id\": \"004@1.0.0\",\r",
					"                            \"cfg\": \"1.0.0\",\r",
					"                            \"txTp\": \"pacs.002.001.12\",\r",
					"                            \"typologies\": [\r",
					"                                {\r",
					"                                    \"id\": \"typology-processor@1.0.0\",\r",
					"                                    \"cfg\": typologyCfg,\r",
					"                                    \"rules\": [\r",
					"                                        {\r",
					"                                            \"id\": ruleResult[0].id,\r",
					"                                            \"cfg\": ruleResult[0].cfg\r",
					"                                        }\r",
					"                                    ]\r",
					"                                }\r",
					"                            ]\r",
					"                        }\r",
					"                    ]\r",
					"                },\r",
					"                \"metaData\": {\r",
					"                    \"prcgTmDP\": 999,\r",
					"                    \"prcgTmED\": 999,\r",
					"                    \"traceParent\": `00-postman-${msgId}-01`\r",
					"                },\r",
					"                typologyResult\r",
					"            }\r",
					"        });\r",
					"    },\r",
					"\r",
					"    getDebtorIdFromPacs008: function (pacs008Message) {\r",
					"\r",
					"        return {\r",
					"            \"id\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].Id,\r",
					"            \"schmeNm\": {\r",
					"                \"prtry\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].SchmeNm.Prtry\r",
					"            }\r",
					"        }\r",
					"\r",
					"    },\r",
					"\r",
					"    getDebtorAccountIdFromPacs008: function (pacs008Message) {\r",
					"\r",
					"        return {\r",
					"            \"id\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].Id,\r",
					"            \"schmeNm\": {\r",
					"                \"prtry\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].SchmeNm.Prtry\r",
					"            },\r",
					"            \"agt\": {\r",
					"                \"finInstnId\": {\r",
					"                    \"clrSysMmbId\": {\r",
					"                        \"mmbId\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAgt.FinInstnId.ClrSysMmbId.MmbId\r",
					"                    }\r",
					"                }\r",
					"            }\r",
					"        }\r",
					"\r",
					"    },\r",
					"\r",
					"    getCreditorIdFromPacs008: function (pacs008Message) {\r",
					"\r",
					"        return {\r",
					"            \"id\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0].Id,\r",
					"            \"schmeNm\": {\r",
					"                \"prtry\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0].SchmeNm.Prtry\r",
					"            }\r",
					"        }\r",
					"\r",
					"    },\r",
					"\r",
					"    getCreditorAccountIdFromPacs008: function (pacs008Message) {\r",
					"\r",
					"        return {\r",
					"            \"id\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].Id,\r",
					"            \"schmeNm\": {\r",
					"                \"prtry\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].SchmeNm.Prtry\r",
					"            },\r",
					"            \"agt\": {\r",
					"                \"finInstnId\": {\r",
					"                    \"clrSysMmbId\": {\r",
					"                        \"mmbId\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAgt.FinInstnId.ClrSysMmbId.MmbId\r",
					"                    }\r",
					"                }\r",
					"            }\r",
					"        }\r",
					"\r",
					"    },\r",
					"\r",
					"    getCreateAccountConditionBody: function (evtTp, condTp, prsptv, incptDtTm, xprtnDtTm, condRsn, acct, forceCret, usr) {\r",
					"\r",
					"        evtTp = evtTp ? evtTp : [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"];\r",
					"        condTp = condTp ? condTp : \"non-overridable-block\"; // \"override\" / \"overridable-block\"\r",
					"        prsptv = prsptv ? prsptv : \"both\";\r",
					"        condRsn = condRsn ? condRsn : \"Default Test Condition\";\r",
					"        acct = acct ? acct : {\r",
					"            \"id\": utils.createISOUUID(),\r",
					"            \"schmeNm\": {\r",
					"                \"prtry\": \"TAZAMA_AID\"\r",
					"            },\r",
					"            \"agt\": {\r",
					"                \"finInstnId\": {\r",
					"                    \"clrSysMmbId\": {\r",
					"                        \"mmbId\": debtorAgentId\r",
					"                    }\r",
					"                }\r",
					"            }\r",
					"        };\r",
					"        forceCret = forceCret ? forceCret : true;\r",
					"        usr = usr ? usr : \"POSTMAN\";\r",
					"\r",
					"        let messageBody = {\r",
					"            \"evtTp\": evtTp,\r",
					"            \"condTp\": condTp,\r",
					"            \"prsptv\": prsptv,\r",
					"            \"condRsn\": condRsn,\r",
					"            \"acct\": acct,\r",
					"            \"forceCret\": forceCret,\r",
					"            \"usr\": usr\r",
					"        };\r",
					"\r",
					"        if (condTp.localeCompare(\"override\") === 0) {\r",
					"            xprtnDtTm = xprtnDtTm ? xprtnDtTm: new Date(new Date(Date.now() + utils.timeframe(\"days\"))).toISOString();\r",
					"        }\r",
					"\r",
					"        incptDtTm = incptDtTm ? messageBody = lodash.assign({\"incptDtTm\": incptDtTm}, messageBody): false;\r",
					"        xprtnDtTm = xprtnDtTm ? messageBody = lodash.assign({\"xprtnDtTm\": xprtnDtTm}, messageBody): false;\r",
					"\r",
					"        return JSON.stringify(messageBody);\r",
					"    },\r",
					"\r",
					"    getCreateEntityConditionBody: function (evtTp, condTp, prsptv, incptDtTm, xprtnDtTm, condRsn, ntty, forceCret, usr) {\r",
					"\r",
					"        evtTp = evtTp ? evtTp : [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"];\r",
					"        condTp = condTp ? condTp : \"non-overridable-block\"; // \"override\" / \"overridable-block\"\r",
					"        prsptv = prsptv ? prsptv : \"both\"; // \"debtor\" / \"creditor\"\r",
					"        condRsn = condRsn ? condRsn : \"Default Test Condition\";\r",
					"        ntty = ntty ? ntty : {\r",
					"            \"id\": utils.createISOUUID(),\r",
					"            \"schmeNm\": {\r",
					"                \"prtry\": \"TAZAMA_EID\"\r",
					"            }\r",
					"        };\r",
					"        forceCret = forceCret ? forceCret : true;\r",
					"        usr = usr ? usr : \"POSTMAN\";\r",
					"\r",
					"        let messageBody = {\r",
					"            \"evtTp\": evtTp,\r",
					"            \"condTp\": condTp,\r",
					"            \"prsptv\": prsptv,\r",
					"            \"condRsn\": condRsn,\r",
					"            \"ntty\": ntty,\r",
					"            \"forceCret\": forceCret,\r",
					"            \"usr\": usr\r",
					"        };\r",
					"\r",
					"        if (condTp.localeCompare(\"override\") === 0) {\r",
					"            xprtnDtTm = xprtnDtTm ? xprtnDtTm: new Date(new Date(Date.now() + utils.timeframe(\"days\"))).toISOString();\r",
					"        }\r",
					"\r",
					"        incptDtTm = incptDtTm ? messageBody = lodash.assign({\"incptDtTm\": incptDtTm}, messageBody): false;\r",
					"        xprtnDtTm = xprtnDtTm ? messageBody = lodash.assign({\"xprtnDtTm\": xprtnDtTm}, messageBody): false;\r",
					"\r",
					"        return JSON.stringify(messageBody);\r",
					"\r",
					"    },\r",
					"    \r",
					"    getConditionsFromDBPostRequest: function (source, id) {\r",
					"\r",
					"        const qryGraphString = `LET vertices = (FOR v,e,p IN 1..2 ANY '${source}/${id}' governed_as_debtor_by, governed_as_debtor_account_by, governed_as_creditor_by, governed_as_creditor_account_by RETURN distinct v) LET edges = (FOR v,e,p IN 1..2 ANY '${source}/${id}' governed_as_debtor_by, governed_as_debtor_account_by, governed_as_creditor_by, governed_as_creditor_account_by RETURN distinct e) RETURN {v: vertices, e: edges}`\r",
					"\r",
					"        return {\r",
					"            url: `${_pm.environment.get('arangoUrl')}/_db/${_pm.environment.get('db_historygraph')}/_api/cursor`,\r",
					"            method: 'POST',\r",
					"            header: { 'Authorization': `Bearer ${_pm.globals.get(\"arangoToken\")}` },\r",
					"            body: {\r",
					"                mode: 'raw',\r",
					"                raw: JSON.stringify({\r",
					"                    query: qryGraphString\r",
					"                })\r",
					"            }\r",
					"        };\r",
					"    },\r",
					"\r",
					"    getConditionsFromGraph: function (graph, all) {\r",
					"\r",
					"        if (all) {\r",
					"            return graph.v.filter(condition => condition._id.substring(0, condition._id.search('/')) === \"conditions\");    // filter to get the conditions\r",
					"        } else {\r",
					"            return graph.v.filter(condition => condition._id.substring(0, condition._id.search('/')) === \"conditions\").map(({ _key }) => _key);    // filter to get the conditions, map to only get the _key;\r",
					"        }\r",
					"    },\r",
					"\r",
					"    getConditionPerspectivesFromGraph: function (graph, condition, all) {\r",
					"\r",
					"        if (all) {\r",
					"            return graph.e.filter(edge => edge._to === \"conditions/\"+condition);   // filter to get the condition's perspectives\r",
					"        } else {\r",
					"            return graph.e.filter(edge => edge._to === \"conditions/\"+condition).map(({ _id }) => _id.substring(0, _id.search('/')));    // filter to get the condition's perspectives, map to only get the _id up to the '/'\r",
					"        }\r",
					"    },\r",
					"\r",
					"    getConditionPerspectiveEventTypesFromGraph: function (graph, condition, perspective) {\r",
					"\r",
					"        return graph.e.filter(edge => edge._to === \"conditions/\"+condition).filter(eventType => eventType._id.substring(0, eventType._id.search('/')) === perspective).map(({ evtTp }) => evtTp);    // filter to get the condition's perspectives, filter to get the specific perspective, map to only get the evtTp\r",
					"    },\r",
					"\r",
					"    getConditionPerspectiveInceptionDateFromGraph: function (graph, condition, perspective) {\r",
					"\r",
					"        return graph.e.filter(edge => edge._to === \"conditions/\"+condition).filter(eventType => eventType._id.substring(0, eventType._id.search('/')) === perspective).map(({ incptnDtTm }) => incptnDtTm);    // filter to get the condition's perspectives, filter to get the specific perspective, map to only get the incptnDtTm\r",
					"    },\r",
					"\r",
					"    getConditionPerspectiveExpirationDateFromGraph: function (graph, condition, perspective) {\r",
					"\r",
					"        return graph.e.filter(edge => edge._to === \"conditions/\"+condition).filter(eventType => eventType._id.substring(0, eventType._id.search('/')) === perspective).map(({ xprtnDtTm }) => xprtnDtTm);    // filter to get the condition's perspectives, filter to get the specific perspective, map to only get the incptnDtTm\r",
					"    }\r",
					"\r",
					"}"
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		}
	]
}